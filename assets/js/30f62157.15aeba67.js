"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4781],{58604:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>d,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"lab/01/index","title":"01 - Debug","description":"Using debug tools to run embassy-rs firmware","source":"@site/versioned_docs/version-fils_en/lab/01/index.mdx","sourceDirName":"lab/01","slug":"/lab/01","permalink":"/docs/fils_en/lab/01","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/lab/01/index.mdx","tags":[],"version":"fils_en","frontMatter":{"description":"Using debug tools to run embassy-rs firmware","slug":"/lab/01"},"sidebar":"tutorialSidebar","previous":{"title":"00 - Intro to Rust","permalink":"/docs/fils_en/lab/00"},"next":{"title":"02 - GPIO","permalink":"/docs/fils_en/lab/02"}}');var r=i(74848),t=i(28453),o=i(65537),a=i(79329);const d={description:"Using debug tools to run embassy-rs firmware",slug:"/lab/01"},l="01 - Debug",c={},h=[{value:"Concepts",id:"concepts",level:2},{value:"Resources",id:"resources",level:2},{value:"Software Prerequisites",id:"software-prerequisites",level:2},{value:"Debugger",id:"debugger",level:2},{value:"Raspberry Pi Debug Probe",id:"raspberry-pi-debug-probe",level:3},{value:"Secondary Pico",id:"secondary-pico",level:3},{value:"Debugger software",id:"debugger-software",level:2},{value:"Cross-compiling",id:"cross-compiling",level:2},{value:"Using a configuration file",id:"using-a-configuration-file",level:3},{value:"Binary format",id:"binary-format",level:2},{value:"Sections",id:"sections",level:3},{value:"Section types",id:"section-types",level:4},{value:"Linker Script",id:"linker-script",level:3},{value:"Build Script",id:"build-script",level:3},{value:"Inspect binaries",id:"inspect-binaries",level:3},{value:"Pico 1 vs Pico 2",id:"pico-1-vs-pico-2",level:4},{value:"Check section headers",id:"check-section-headers",level:3},{value:"Empty firmware",id:"empty-firmware",level:2},{value:"The <code>.interrupt_vector</code> section",id:"the-interrupt_vector-section",level:3},{value:"The <code>.start_block</code> and <code>.end_block</code>s",id:"the-start_block-and-end_blocks",level:3},{value:"The <code>main</code> function",id:"the-main-function",level:3},{value:"Flashing firmware",id:"flashing-firmware",level:2},{value:"Using <code>cargo run</code>",id:"using-cargo-run",level:3},{value:"Printing messages",id:"printing-messages",level:2},{value:"Semihosting",id:"semihosting",level:3},{value:"Printing a message",id:"printing-a-message",level:4},{value:"Printing the panic",id:"printing-the-panic",level:4},{value:"Using <code>defmt</code>",id:"using-defmt",level:3},{value:"Transports",id:"transports",level:4},{value:"Example",id:"example",level:4},{value:"Filtering messages",id:"filtering-messages",level:4},{value:"Semihosting and <code>defmt</code>",id:"semihosting-and-defmt",level:3},{value:"Exercises",id:"exercises",level:2},{value:"VS Code probe-rs Extension",id:"vs-code-probe-rs-extension",level:2},{value:"Set up <code>launch.json</code>",id:"set-up-launchjson",level:3},{value:"Running the firmware",id:"running-the-firmware",level:3},{value:"Starting the Debugging Session",id:"starting-the-debugging-session",level:4},{value:"Checking for Errors and Debug Output",id:"checking-for-errors-and-debug-output",level:4},{value:"Stopping the Running Firmware",id:"stopping-the-running-firmware",level:4},{value:"Using Breakpoints",id:"using-breakpoints",level:3},{value:"Placing a Breakpoint",id:"placing-a-breakpoint",level:4},{value:"Starting and Hitting a Breakpoint",id:"starting-and-hitting-a-breakpoint",level:4},{value:"Stepping Through Code",id:"stepping-through-code",level:4},{value:"Removing or Disabling Breakpoints",id:"removing-or-disabling-breakpoints",level:4},{value:"Watches",id:"watches",level:3},{value:"Call Stack: Tracing Function Execution",id:"call-stack-tracing-function-execution",level:3},{value:"How to Use the Call Stack",id:"how-to-use-the-call-stack",level:4},{value:"Why Use the Call Stack?",id:"why-use-the-call-stack",level:4},{value:"Peripherals: Inspecting Hardware Registers",id:"peripherals-inspecting-hardware-registers",level:3},{value:"SVD Files for The Raspberry Pi Pico",id:"svd-files-for-the-raspberry-pi-pico",level:4},{value:"How to Enable Peripheral Debugging",id:"how-to-enable-peripheral-debugging",level:4},{value:"<strong>Why Use the Peripherals Panel?</strong>",id:"why-use-the-peripherals-panel",level:4},{value:"Extra exercises",id:"extra-exercises",level:2}];function u(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"01---debug",children:"01 - Debug"})}),"\n",(0,r.jsxs)(n.p,{children:["This lab will teach you how to debug and run programs written in Rust and ",(0,r.jsx)(n.a,{href:"https://embassy.dev",children:"embassy"})," on the Raspberry Pi Pico boards."]}),"\n","\n",(0,r.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"How to debug a microcontroller's firmware"}),"\n",(0,r.jsx)(n.li,{children:"How the binary of the firmware looks like and how to inspect it"}),"\n",(0,r.jsx)(n.li,{children:"How to cross-compile Rust software"}),"\n",(0,r.jsxs)(n.li,{children:["How to use ",(0,r.jsx)(n.code,{children:"probe-rs"})," for RP2 processors"]}),"\n",(0,r.jsx)(n.li,{children:"How to print messages from a microcontroller"}),"\n",(0,r.jsx)(n.li,{children:"How to use the Visual Studio Code probe-rs extension"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Raspberry Pi Ltd"}),", ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.a,{href:"https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf",children:"RP2350 Datasheet"})})]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Chapter 4 - ",(0,r.jsx)(n.em,{children:"Memory"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Section 4.1 - ",(0,r.jsx)(n.em,{children:"ROM"})]}),"\n",(0,r.jsxs)(n.li,{children:["Section 4.2 - ",(0,r.jsx)(n.em,{children:"SRAM"})]}),"\n",(0,r.jsxs)(n.li,{children:["Section 4.3 - ",(0,r.jsx)(n.em,{children:"Boot RAM"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Chapter 5 - ",(0,r.jsx)(n.em,{children:"Bootrom"})]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://probe.rs/docs/overview/about-probe-rs/",children:"probe-rs's documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.rs/rp235x-hal/latest/rp235x_hal/index.html",children:"rp235x-hal documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://embassy.dev/book/dev/runtime.html",children:"Embassy documentation"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"software-prerequisites",children:"Software Prerequisites"}),"\n",(0,r.jsx)(n.p,{children:"Please make sure that you have these installed."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.rust-lang.org/learn/get-started",children:"Rust"})}),"\n",(0,r.jsxs)(n.li,{children:["Rust ARMv8-M target - ",(0,r.jsx)(n.code,{children:"rustup target add thumbv8m.main-none-eabihf"})]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://probe.rs",children:"probe-rs"})}),"\n",(0,r.jsxs)(n.li,{children:["cargo binutils - ",(0,r.jsx)(n.code,{children:"cargo install cargo-binutils"})]}),"\n",(0,r.jsxs)(n.li,{children:["Rust LLVM Tools - ",(0,r.jsx)(n.code,{children:"rustup component add llvm-tools"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://code.visualstudio.com",children:"Visual Studio Code"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=probe-rs.probe-rs-debugger",children:"Debugger for probe-rs"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"debugger",children:"Debugger"}),"\n",(0,r.jsxs)(n.p,{children:["Developing software (",(0,r.jsx)(n.em,{children:"firmware"}),(0,r.jsx)(n.sup,{children:(0,r.jsx)(n.a,{href:"#user-content-fn-firmware",id:"user-content-fnref-firmware","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),") on devices is a little different from standard computer applications. The main difference\nis that the software is developed and compiled on the computer and then\nuploaded and run on a separate device."]}),"\n",(0,r.jsxs)(n.p,{children:["Each development board defines its own way of uploading software to it. Some boards, like the Raspberry Pi Picos, provide a ",(0,r.jsx)(n.em,{children:"simulated"})," USB drive\nwhere users can copy a file, others, like the ESP32 boards, provide a WiFi Access Point and a web interface."]}),"\n",(0,r.jsxs)(n.p,{children:["One method that all boards have in common is using the ",(0,r.jsx)(n.em,{children:"debug interface"}),". Microcontrollers provide a special hardware interface\nfor debugging purposes. Using specialized hardware, developers can:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"stop the processor any time"}),"\n",(0,r.jsx)(n.li,{children:"ask the processor to execute one instruction at a time"}),"\n",(0,r.jsx)(n.li,{children:"read and write the processor's memory (RAM)"}),"\n",(0,r.jsx)(n.li,{children:"read and write the processor's Flash (Storage)"}),"\n",(0,r.jsx)(n.li,{children:"read the processor's registers"}),"\n",(0,r.jsx)(n.li,{children:"access special debugging interfaces for sending log messages"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These functions allow developers to upload programs and observe the program's behavior."}),"\n",(0,r.jsx)(n.p,{children:"There are several debugging protocols available, the most common of them being JTAG and SWD. The RP2 processors use SWD."}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsxs)(n.p,{children:["When placed in production, the ",(0,r.jsx)(n.strong,{children:"debug interface should be disabled"}),". Users of the production device should\nnever be able to access such an interface and tamper with the device's program."]}),(0,r.jsx)(n.p,{children:"Each microcontroller offers a way in which the debug interface can be permanently disabled or restricted."})]}),"\n",(0,r.jsx)(n.p,{children:"The Raspberry Pi Pico can be debugged using one of the two pieces of hardware:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The Raspberry Pi Debug Probe"}),"\n",(0,r.jsx)(n.li,{children:"A secondary Raspberry Pi Pico"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"raspberry-pi-debug-probe",children:"Raspberry Pi Debug Probe"}),"\n",(0,r.jsxs)(n.p,{children:["Professional debuggers, while offering a lot of features, are usually expensive. Raspberry Pi provides the ",(0,r.jsx)(n.a,{href:"https://www.raspberrypi.com/products/debug-probe/",children:"Debug Probe"}),", an affordable debug device\nthat uses an RP2040 processor. It is similar to a Raspberry Pi Pico board, just that it has a smaller form factor and\nprovides debug cables."]}),"\n",(0,r.jsxs)(n.p,{children:["The firmware running on the debug device is open source and available on ",(0,r.jsx)(n.a,{href:"https://github.com/raspberrypi/debugprobe",children:"github"}),". It is written in C and\nit uses ",(0,r.jsx)(n.a,{href:"https://www.freertos.org",children:"FreeRTOS"}),". It is compatible with both versions of the RP2 processors, RP2040 and RP2350."]}),"\n",(0,r.jsxs)(n.p,{children:["The details about the wiring are available on the Pico Debug Probe's ",(0,r.jsx)(n.a,{href:"https://www.raspberrypi.com/documentation/microcontrollers/debug-probe.html#getting-started",children:"website"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"secondary-pico",children:"Secondary Pico"}),"\n",(0,r.jsx)(n.p,{children:"As the debugger's firmware is open source, an additional Raspberry Pi Pico can be used as a debugger."}),"\n",(0,r.jsxs)(n.p,{children:["The details about the wiring are available in the ",(0,r.jsx)(n.a,{href:"https://datasheets.raspberrypi.com/pico/getting-started-with-pico.pdf",children:"Getting started with Raspberry Pi\nPico-series"})," in the ",(0,r.jsx)(n.em,{children:"Debug with a second Pico or Pico 2"})," section."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"A Pico debugging another Pico",src:i(76958).A+"",width:"782",height:"594"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The lab board uses RP2040 processor soldered to the PCB as a debugger. It runs the ",(0,r.jsx)(n.a,{href:"https://github.com/raspberrypi/debugprobe",children:"debugprobe"})," firmware and has\ntraces soldered to Raspberry Pi Pico's socket."]})}),"\n",(0,r.jsx)(n.h2,{id:"debugger-software",children:"Debugger software"}),"\n",(0,r.jsx)(n.p,{children:"Hardware debuggers require specialized software on the host computer (the computer used for development) to\ncommunicate with and control the target device (the Raspberry Pi Pico 2 in this case). These software tools provide\nessential debugging capabilities, such as setting breakpoints, inspecting\nmemory, and stepping through code execution. While most debugger vendors offer\nproprietary software tailored to their specific hardware, developers often seek\nmore flexible or platform-independent solutions. Fortunately, there are several\nopen-source alternatives that support a wide range of debugging probes and\nmicrocontrollers."}),"\n",(0,r.jsxs)(n.p,{children:["One widely used open-source tool is ",(0,r.jsx)(n.a,{href:"https://openocd.org",children:"OpenOCD"}),", which\nprovides a powerful and configurable interface for debugging and programming\nARM and RISC-V devices, including the Raspberry Pi Pico 2. OpenOCD supports a\nvariety of debug probes and allows integration with GDB for source-level\ndebugging."]}),"\n",(0,r.jsxs)(n.p,{children:["Another popular option is ",(0,r.jsx)(n.a,{href:"https://pyocd.io",children:"PyOCD"}),", a Python-based tool\ndesigned primarily for ARM Cortex-M microcontrollers. It offers an easy-to-use\ncommand-line interface, built-in support for CMSIS-DAP debug probes, and\nseamless integration with debugging environments like GDB and Visual Studio\nCode."]}),"\n",(0,r.jsxs)(n.p,{children:["For developers working in Rust or looking for an alternative that is optimized\nfor modern workflows, ",(0,r.jsx)(n.a,{href:"https://probe.rs",children:"probe-rs"})," provides a Rust-based\ndebugging and flashing tool that supports multiple probe types, including\nCMSIS-DAP and J-Link. It offers a simple API, making it a great choice for both\nmanual debugging and automated workflows."]}),"\n",(0,r.jsx)(n.h2,{id:"cross-compiling",children:"Cross-compiling"}),"\n",(0,r.jsx)(n.p,{children:"Cross-compiling is the process of building software on one system (the host)\nthat is intended to run on a different system (the target). This is necessary\nwhen developing for embedded systems like the Raspberry Pi Pico 2 because the\ntarget device has a different processor architecture than the development\ncomputer. Unlike normal compiling, where the compiled binary runs on the same\nsystem that builds it, cross-compiling generates machine code suitable for the\ntarget architecture."}),"\n",(0,r.jsxs)(n.p,{children:["In Rust, this is handled by specifying a target triple.\nFor example, when using ",(0,r.jsx)(n.code,{children:"cargo build"})," for embedded development, Rust compiles\nthe firmware for the microcontroller's architecture and flashes it to the\ndevice."]}),"\n",(0,r.jsxs)(n.p,{children:["For example, cross-compiling for the Raspberry Pi Pico 2 requires the\n",(0,r.jsx)(n.code,{children:"thumbv8m.main-none-eabihf"})," triple. It tells the compiler to build code\nfor:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["the ",(0,r.jsx)(n.strong,{children:"ARMv8-M Mainline"})," (",(0,r.jsx)(n.code,{children:"thumbv8m.main"}),") architecture"]}),"\n",(0,r.jsxs)(n.li,{children:["that runs bare metal, ",(0,r.jsx)(n.strong,{children:"without an operating system"})," available (",(0,r.jsx)(n.code,{children:"none"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["and uses the ",(0,r.jsx)(n.strong,{children:"Embedded Application Binary Interface"})," (",(0,r.jsx)(n.code,{children:"eabi"}),") ",(0,r.jsx)(n.strong,{children:"with hardware floating point"})," support"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"cargo build --target thumbv8m.main-none-eabihf\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-a-configuration-file",children:"Using a configuration file"}),"\n",(0,r.jsxs)(n.p,{children:["Instead of providing the target triple in the command line every time, ",(0,r.jsx)(n.code,{children:"cargo"})," offers the\npossibility of writing it in a configuration file called ",(0,r.jsx)(n.code,{children:".cargo/config.toml"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'[build]\ntarget = "thumbv8m.main-none-eabihf"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This sets the default compilation target to ",(0,r.jsx)(n.code,{children:"thumbv8m.main-none-eabihf"}),",\nensuring that ",(0,r.jsx)(n.code,{children:"cargo"})," always builds the project for an ",(0,r.jsx)(n.em,{children:"ARMv8-M Mainline"}),"\nmicrocontroller with hardware floating-point support."]}),"\n",(0,r.jsxs)(n.p,{children:["With this setting, running ",(0,r.jsx)(n.code,{children:"cargo build"})," or ",(0,r.jsx)(n.code,{children:"cargo run"})," automatically\ncompiles for the specified target, making cross-compilation seamless."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The target triple for the Raspberry Pi Pico 1 is ",(0,r.jsx)(n.code,{children:"thumbv6m-none-eabi"}),"."]})}),"\n",(0,r.jsx)(n.h2,{id:"binary-format",children:"Binary format"}),"\n",(0,r.jsx)(n.p,{children:"To be able to properly run the code, the Raspberry Pi Pico (1 and 2) expects a certain binary format.\nThe compiler and the linker, both provided by Rust, have to make sure that the generated\nbinary code meets the requirements, otherwise the Raspberry Pi Pico will not start."}),"\n",(0,r.jsx)(n.h3,{id:"sections",children:"Sections"}),"\n",(0,r.jsx)(n.p,{children:"The binary file is generated as a collection of sections. Each section has:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"size (in bytes)"}),"\n",(0,r.jsxs)(n.li,{children:["the address of the section in RAM when the firmware runs (",(0,r.jsx)(n.code,{children:"VMA"}),", ",(0,r.jsx)(n.em,{children:"Virtual Memory Address"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["the address of the section when it is stored into flash (",(0,r.jsx)(n.code,{children:"LMA"}),", ",(0,r.jsx)(n.em,{children:"Load Memory Address"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"the type"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"section-types",children:"Section types"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"TEXT"})}),(0,r.jsx)(n.td,{children:"Contains the binary code the the processor executes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"DATA"})}),(0,r.jsx)(n.td,{children:"Contains data used by the firmware, usually variables"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"BSS"})}),(0,r.jsxs)(n.td,{children:["Contains uninitialized or initialized with ",(0,r.jsx)(n.code,{children:"0"})," data, usually uninitialized global variables and variables initialized to 0"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"DEBUG"})}),(0,r.jsx)(n.td,{children:"Contains debug information used by the debugger software."})]})]})]}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:["DEBUG type sections have no addresses (",(0,r.jsx)(n.code,{children:"0x00000000"}),"), as they are never loaded to the device. These sections\nare used by the debugging software to display meaningful information to developers. Among the information\nstore here we can find:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"source code to binary code mappings"}),"\n",(0,r.jsx)(n.li,{children:"variable name mappings"}),"\n",(0,r.jsx)(n.li,{children:"function name mappings"}),"\n"]})]}),"\n",(0,r.jsxs)(n.p,{children:["The binary file for the Raspberry Pi Pico 2 is organized to ensure proper\nexecution and booting, with specific sections for the developer's code and\nvariables. The first section that holds the developer\u2019s code is the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".text"})}),"\nsection. This section contains all the executable instructions that make up\nthe application\u2019s logic. It is located after the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".start_block"})})," and\n",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".vector_table"})})," sections, and it is placed into flash memory, ready to\nbe loaded and executed when the system starts. This is where the developer's\nmain program logic resides."]}),"\n",(0,r.jsxs)(n.p,{children:["Following the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".text"})})," section, the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".data"})})," section contains\ninitialized global and static variables. These variables are stored in flash\nmemory and are copied into RAM at startup. The developer\u2019s predefined values\nfor global variables are stored here, so they can be used during runtime.\nIn contrast, the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".bss"})})," section holds uninitialized variables. These\nvariables are zeroed out during the boot process and are stored in RAM to\nensure that the program can access them during execution."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".rodata"})})," section follows, storing read-only data like string literals\nand constant values. These values are also stored in flash memory and are used\nthroughout the application without modification. The ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".rodata"})})," section\nhelps to conserve RAM by storing constant data in the flash memory instead."]}),"\n",(0,r.jsxs)(n.p,{children:["Once the developer\u2019s code and variables are in place, the firmware image ends\nwith the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".end_block"})})," section. This section marks the end of the firmware\nand ensures that no additional data is written past this point. It is important\nfor memory management, preventing the accidental overwrite of critical memory\nregions during updates or execution."]}),"\n",(0,r.jsx)(n.h3,{id:"linker-script",children:"Linker Script"}),"\n",(0,r.jsxs)(n.p,{children:["The compiler is responsible for generating the sections and the linker is responsible for\nputting the sections in the right place in the binary. Rust uses a linker script to\ninstruct the linker where to put the sections. The linker script is usually called\n",(0,r.jsx)(n.code,{children:"memory.x"})," and is located in the firmware's root folder."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["The linker script is in the firmware's crate root folder, not in the ",(0,r.jsx)(n.code,{children:"src"})," folder."]})}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(a.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ld",children:"MEMORY {\n    /*\n     * The RP2350 has either external or internal flash.\n     *\n     * 2 MiB is a safe default here, although a Pico 2 has 4 MiB.\n     */\n    FLASH : ORIGIN = 0x10000000, LENGTH = 2048K\n    /*\n     * RAM consists of 8 banks, SRAM0-SRAM7, with a striped mapping.\n     * This is usually good for performance, as it distributes load on\n     * those banks evenly.\n     */\n    RAM : ORIGIN = 0x20000000, LENGTH = 512K\n    /*\n     * RAM banks 8 and 9 use a direct mapping. They can be used to have\n     * memory areas dedicated for some specific job, improving predictability\n     * of access times.\n     * Example: Separate stacks for core0 and core1.\n     */\n    SRAM4 : ORIGIN = 0x20080000, LENGTH = 4K\n    SRAM5 : ORIGIN = 0x20081000, LENGTH = 4K\n}\n\nSECTIONS {\n    /* ### Boot ROM info\n     *\n     * Goes after .vector_table, to keep it in the first 4K of flash\n     * where the Boot ROM (and picotool) can find it\n     */\n    .start_block : ALIGN(4)\n    {\n        __start_block_addr = .;\n        KEEP(*(.start_block));\n        KEEP(*(.boot_info));\n    } > FLASH\n\n} INSERT AFTER .vector_table;\n\n/* move .text to start /after/ the boot info */\n_stext = ADDR(.start_block) + SIZEOF(.start_block);\n\nSECTIONS {\n    /* ### Picotool 'Binary Info' Entries\n     *\n     * Picotool looks through this block (as we have pointers to it in our\n     * header) to find interesting information.\n     */\n    .bi_entries : ALIGN(4)\n    {\n        /* We put this in the header */\n        __bi_entries_start = .;\n        /* Here are the entries */\n        KEEP(*(.bi_entries));\n        /* Keep this block a nice round size */\n        . = ALIGN(4);\n        /* We put this in the header */\n        __bi_entries_end = .;\n    } > FLASH\n} INSERT AFTER .text;\n\nSECTIONS {\n    /* ### Boot ROM extra info\n     *\n     * Goes after everything in our program, so it can contain a signature.\n     */\n    .end_block : ALIGN(4)\n    {\n        __end_block_addr = .;\n        KEEP(*(.end_block));\n    } > FLASH\n\n} INSERT AFTER .uninit;\n\nPROVIDE(start_to_end = __end_block_addr - __start_block_addr);\nPROVIDE(end_to_start = __start_block_addr - __end_block_addr);\n"})})}),(0,r.jsx)(a.A,{value:"rp2040",label:"Raspberry Pi Pico",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ld",children:"MEMORY {\n    BOOT2 : ORIGIN = 0x10000000, LENGTH = 0x100\n    /*\n     * Here we assume you have 2048 KiB of Flash. This is what the Pi Pico\n     * has, but your board may have more or less Flash and you should adjust\n     * this value to suit.\n     */\n    FLASH : ORIGIN = 0x10000100, LENGTH = 2048K - 0x100\n    /*\n     * RAM consists of 4 banks, SRAM0-SRAM3, with a striped mapping.\n     * This is usually good for performance, as it distributes load on\n     * those banks evenly.\n     */\n    RAM : ORIGIN = 0x20000000, LENGTH = 256K\n    /*\n     * RAM banks 4 and 5 use a direct mapping. They can be used to have\n     * memory areas dedicated for some specific job, improving predictability\n     * of access times.\n     * Example: Separate stacks for core0 and core1.\n     */\n    SRAM4 : ORIGIN = 0x20040000, LENGTH = 4k\n    SRAM5 : ORIGIN = 0x20041000, LENGTH = 4k\n\n    /* SRAM banks 0-3 can also be accessed directly. However, those ranges\n       alias with the RAM mapping, above. So don't use them at the same time!\n    SRAM0 : ORIGIN = 0x21000000, LENGTH = 64k\n    SRAM1 : ORIGIN = 0x21010000, LENGTH = 64k\n    SRAM2 : ORIGIN = 0x21020000, LENGTH = 64k\n    SRAM3 : ORIGIN = 0x21030000, LENGTH = 64k\n    */\n}\n\nEXTERN(BOOT2_FIRMWARE)\n\nSECTIONS {\n    /* ### Boot loader\n     *\n     * An executable block of code which sets up the QSPI interface for\n     * 'Execute-In-Place' (or XIP) mode. Also sends chip-specific commands to\n     * the external flash chip.\n     *\n     * Must go at the start of external flash, where the Boot ROM expects it.\n     */\n    .boot2 ORIGIN(BOOT2) :\n    {\n        KEEP(*(.boot2));\n    } > BOOT2\n} INSERT BEFORE .text;\n\nSECTIONS {\n    /* ### Boot ROM info\n     *\n     * Goes after .vector_table, to keep it in the first 512 bytes of flash,\n     * where picotool can find it\n     */\n    .boot_info : ALIGN(4)\n    {\n        KEEP(*(.boot_info));\n    } > FLASH\n\n} INSERT AFTER .vector_table;\n\n/* move .text to start /after/ the boot info */\n_stext = ADDR(.boot_info) + SIZEOF(.boot_info);\n\nSECTIONS {\n    /* ### Picotool 'Binary Info' Entries\n     *\n     * Picotool looks through this block (as we have pointers to it in our\n     * header) to find interesting information.\n     */\n    .bi_entries : ALIGN(4)\n    {\n        /* We put this in the header */\n        __bi_entries_start = .;\n        /* Here are the entries */\n        KEEP(*(.bi_entries));\n        /* Keep this block a nice round size */\n        . = ALIGN(4);\n        /* We put this in the header */\n        __bi_entries_end = .;\n    } > FLASH\n} INSERT AFTER .text;\n"})})})]}),"\n",(0,r.jsx)(n.h3,{id:"build-script",children:"Build Script"}),"\n",(0,r.jsxs)(n.p,{children:["To connect the linker script (",(0,r.jsx)(n.code,{children:"memory.x"}),") to the compiler, Rust uses the ",(0,r.jsx)(n.code,{children:"build.rs"})," file\nlocated in the root of the firmware's crate."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"build.rs"})," file is located in the root of the firmware's crate, not in the ",(0,r.jsx)(n.code,{children:"src"})," folder."]})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"build.rs"})," file compiles before the firmware and is executed by the Rust compiler during\nthe compilation. The ",(0,r.jsx)(n.code,{children:"build.rs"})," file writes to the ",(0,r.jsx)(n.em,{children:"screen"})," compiler options that the compiler\nlater uses for the building of the firmware."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'//! This build script copies the `memory.x` file from the crate root into\n//! a directory where the linker can always find it at build time.\n//! For many projects this is optional, as the linker always searches the\n//! project root directory -- wherever `Cargo.toml` is. However, if you\n//! are using a workspace or have a more complicated build setup, this\n//! build script becomes required. Additionally, by requesting that\n//! Cargo re-run the build script whenever `memory.x` is changed,\n//! updating `memory.x` ensures a rebuild of the application with the\n//! new memory settings.\n\nuse std::env;\nuse std::fs::File;\nuse std::io::Write;\nuse std::path::PathBuf;\n\nfn main() {\n    // Put `memory.x` in our output directory and ensure it\'s\n    // on the linker search path.\n    let out = &PathBuf::from(env::var_os("OUT_DIR").unwrap());\n    File::create(out.join("memory.x"))\n        .unwrap()\n        .write_all(include_bytes!("memory.x"))\n        .unwrap();\n    println!("cargo:rustc-link-search={}", out.display());\n\n    // By default, Cargo will re-run a build script whenever\n    // any file in the project changes. By specifying `memory.x`\n    // here, we ensure the build script is only re-run when\n    // `memory.x` is changed.\n    println!("cargo:rerun-if-changed=memory.x");\n\n    println!("cargo:rustc-link-arg-bins=--nmagic");\n    println!("cargo:rustc-link-arg-bins=-Tlink.x");\n    // Required for `defmt`\n    println!("cargo:rustc-link-arg-bins=-Tdefmt.x");\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This example instructs the linker to use:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["the project's linker script - ",(0,r.jsx)(n.code,{children:"memory.x"})]}),"\n",(0,r.jsxs)(n.li,{children:["the ",(0,r.jsx)(n.code,{children:"cortex-m-rt"})," linker script - ",(0,r.jsx)(n.code,{children:"link.x"})]}),"\n",(0,r.jsxs)(n.li,{children:["the ",(0,r.jsx)(n.code,{children:"defmt"}),"'s linker script - ",(0,r.jsx)(n.code,{children:"defmt.x"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"inspect-binaries",children:"Inspect binaries"}),"\n",(0,r.jsxs)(n.p,{children:["When working in Rust for the Raspberry Pi Pico 2, ",(0,r.jsx)(n.code,{children:"rust-objdump"})," can be used to\ninspect the compiled binary and examine its memory layout. The output includes\nvarious sections that are crucial for embedded development."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Section"}),(0,r.jsx)(n.th,{children:"Fixed Offset"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".vector_table"})})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"0x10000000"})}),(0,r.jsx)(n.td,{children:"Contains the initial stack pointer value and interrupt vector table. Essential for system startup and exception handling, allowing the processor to correctly respond to interrupts."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".start_block"})})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"0x10000114"})}),(0,r.jsx)(n.td,{children:"Holds boot metadata, including information needed by the bootloader to validate and execute the firmware correctly. Ensures that the correct application runs after a reset."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".text"})})}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"Stores executable code, typically placed in flash memory. Optimizing this section can reduce flash usage and improve execution efficiency."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".rodata"})})}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"Contains read-only data, such as string literals and constants, stored in flash memory. Helps minimize RAM usage."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".data"})})}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"Includes initialized variables that are stored in flash and copied to RAM during startup. Used for global and static variables requiring predefined values."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".bss"})})}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsxs)(n.td,{children:["Represents uninitialized variables that are zeroed out in RAM before execution. Large ",(0,r.jsx)(n.code,{children:".bss"})," sections can impact RAM availability."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".bi_entries"})})}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"Contains boot information entries used by the RP2350 ROM bootloader and firmware updater to manage and validate firmware images."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".end_block"})})}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"Marks the end of the firmware image. This section helps bootloaders determine the total size of the firmware and ensures that no unexpected data is included beyond this point. It is used for integrity checks and defining boundaries for updates or memory protection."})]})]})]}),"\n",(0,r.jsx)(n.h4,{id:"pico-1-vs-pico-2",children:"Pico 1 vs Pico 2"}),"\n",(0,r.jsxs)(n.p,{children:["The primary difference between the Raspberry Pi Pico 1 and Pico 2 in terms of\nfirmware layout is the presence of the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".boot2"})})," section in the Pico 1,\nwhich is not present in the Pico 2. The ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".boot2"})})," section in the Pico 1\nis located at a fixed offset of ",(0,r.jsx)(n.code,{children:"0x10000000"})," and contains the bootloader code\nalong with necessary metadata for bootstrapping the device."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".vector_table"})}),"  section in the Pico 1 is placed immediately\nafter the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".boot2"})})," section,\nunlike the Pico 2 where it is located at the beginning of the flash memory at\n",(0,r.jsx)(n.code,{children:"0x00000000"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The Pico 2 uses the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".start_block"})})," and ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".end_block"})})," sections\nto handle boot metadata and firmware boundaries, while the Pico 1 relies on the\nbootloader for these tasks. Furthermore, the Pico 1 does not have a fixed\n",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".end_block"})})," section, which is used in the Pico 2 to mark the end of the\nfirmware image."]}),"\n",(0,r.jsxs)(n.p,{children:["Despite these differences, both devices share a similar overall\nfirmware structure, with the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".text"})}),", ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".rodata"})}),", ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".data"})}),", and ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:".bss"})}),"\nsections serving similar purposes in both devices."]}),"\n",(0,r.jsx)(n.h3,{id:"check-section-headers",children:"Check section headers"}),"\n",(0,r.jsx)(n.p,{children:"If the uploaded firmware does not boot, looking at the firmware's sections is useful."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"rust-objdumb"})," tool can be used to inspect firmware binaries. Using the ",(0,r.jsx)(n.code,{children:"--section-headers"}),"\nflag will display the sections of the firmware."]}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsxs)(a.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"rust-objdump --section-headers target/thumbv8m.main-none-eabihf/debug/$app_name\n"})}),(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsx)(n.p,{children:"Make sure that:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["section ",(0,r.jsx)(n.code,{children:".vector_table"})," is ",(0,r.jsx)(n.code,{children:"0x114"})," long and at ",(0,r.jsx)(n.code,{children:"0x10000000"})]}),"\n",(0,r.jsxs)(n.li,{children:["section ",(0,r.jsx)(n.code,{children:".start_block"})," is at ",(0,r.jsx)(n.code,{children:"0x10000114"})]}),"\n",(0,r.jsxs)(n.li,{children:["section ",(0,r.jsx)(n.code,{children:".end_block"})," exists"]}),"\n"]})]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"Sections:\nIdx Name            Size     VMA      LMA      Type\n  0                 00000000 00000000 00000000 \n  1 .vector_table   00000114 10000000 10000000 DATA\n  2 .start_block    00000028 10000114 10000114 DATA\n  3 .text           0000b190 1000013c 1000013c TEXT\n  4 .bi_entries     00000010 1000b2cc 1000b2cc DATA\n  5 .rodata         000030e4 1000b2e0 1000b2e0 DATA\n  6 .data           00000488 20000000 1000e3c4 TEXT\n  7 .gnu.sgstubs    00000000 1000e860 1000e860 DATA\n  8 .bss            000181bc 20000488 20000488 BSS\n  9 .uninit         00000400 20018644 20018644 BSS\n 10 .end_block      00000000 1000e860 1000e860 DATA\n 11 .defmt          00000023 00000000 00000000 \n 12 .debug_abbrev   0000b8bb 00000000 00000000 DEBUG\n 13 .debug_info     000ea40f 00000000 00000000 DEBUG\n 14 .debug_aranges  00009a70 00000000 00000000 DEBUG\n 15 .debug_ranges   00032380 00000000 00000000 DEBUG\n 16 .debug_str      000eff8d 00000000 00000000 DEBUG\n 17 .comment        00000099 00000000 00000000 \n 18 .ARM.attributes 0000003a 00000000 00000000 \n 19 .debug_frame    0001b444 00000000 00000000 DEBUG\n 20 .debug_line     0006ed68 00000000 00000000 DEBUG\n 21 .debug_loc      00001e3a 00000000 00000000 DEBUG\n 22 .symtab         00007530 00000000 00000000 \n 23 .shstrtab       00000101 00000000 00000000 \n 24 .strtab         0000f6ca 00000000 00000000 \n"})})]}),(0,r.jsxs)(a.A,{value:"rp2040",label:"Raspberry Pi Pico",children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"rust-objdump --section-headers target/thumbv6m-none-eabi/debug/$app_name\n"})}),(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsx)(n.p,{children:"Make sure that:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["section ",(0,r.jsx)(n.code,{children:".boot2"})," is ",(0,r.jsx)(n.code,{children:"0x100"})," long and at ",(0,r.jsx)(n.code,{children:"0x10000000"})]}),"\n",(0,r.jsxs)(n.li,{children:["section ",(0,r.jsx)(n.code,{children:".vector_table"})," is ",(0,r.jsx)(n.code,{children:"0x0c0"})," long and at ",(0,r.jsx)(n.code,{children:"0x10000100"})]}),"\n"]})]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"Sections:\nIdx Name            Size     VMA      LMA      Type\n  0                 00000000 00000000 00000000 \n  1 .vector_table   000000c0 10000100 10000100 DATA\n  2 .boot_info      00000000 100001c0 100001c0 DATA\n  3 .boot2          00000100 10000000 10000000 DATA\n  4 .text           000027d8 100001c0 100001c0 TEXT\n  5 .bi_entries     00000000 10002998 10002998 DATA\n  6 .rodata         00000d00 10002998 10002998 DATA\n  7 .data           00000038 20000000 10003698 DATA\n  8 .gnu.sgstubs    00000000 100036e0 100036e0 DATA\n  9 .bss            00000008 20000038 20000038 BSS\n 10 .uninit         00000400 20000040 20000040 BSS\n 11 .defmt          0000000a 00000000 00000000 \n 12 .debug_abbrev   00005fc3 00000000 00000000 DEBUG\n 13 .debug_info     000aa259 00000000 00000000 DEBUG\n 14 .debug_aranges  00006df8 00000000 00000000 DEBUG\n 15 .debug_ranges   0001d2d8 00000000 00000000 DEBUG\n 16 .debug_str      000e4147 00000000 00000000 DEBUG\n 17 .comment        00000099 00000000 00000000 \n 18 .ARM.attributes 00000032 00000000 00000000 \n 19 .debug_frame    0001466c 00000000 00000000 DEBUG\n 20 .debug_line     00049f95 00000000 00000000 DEBUG\n 21 .debug_loc      0000141b 00000000 00000000 DEBUG\n 22 .symtab         00001ec0 00000000 00000000 \n 23 .shstrtab       000000fb 00000000 00000000 \n 24 .strtab         000035f6 00000000 00000000 \n"})})]})]}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"cargo objdumb"})," and ",(0,r.jsx)(n.code,{children:"rust-objdump"})," tools use llvm's ",(0,r.jsx)(n.code,{children:"objdump"})," tool.\nSome terminals do not parse parameters proxied to ",(0,r.jsx)(n.code,{children:"llvm-objdump"})," command.\nIf this happens please use ",(0,r.jsx)(n.code,{children:"llvm-objdump"})," script directly like so"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"llvm-objdump <path_to_binary> --section.headers\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"empty-firmware",children:"Empty firmware"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.em,{children:"empty firmware"})," is a piece of software running on a device that boots and puts\nthe device in an endless loop. To boot, the firmware has to perform the following:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["do not depend on the standard library (",(0,r.jsx)(n.code,{children:"#![no_std]"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["do not provide the standard ",(0,r.jsx)(n.code,{children:"main"})," function called by the operating system (",(0,r.jsx)(n.code,{children:"#![no_main]"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["provide the ",(0,r.jsx)(n.code,{children:".start_block"})," and ",(0,r.jsx)(n.code,{children:".end_block"})," sections (or ",(0,r.jsx)(n.code,{children:".bootloader"})," for the Pico 1);"]}),"\n",(0,r.jsxs)(n.li,{children:["provide the ",(0,r.jsx)(n.code,{children:".interrupt_vector"})," section with pointers to interrupts;"]}),"\n",(0,r.jsx)(n.li,{children:"copy the DATA sections from Flash to the correct address in RAM;"}),"\n",(0,r.jsx)(n.li,{children:"initialize the BSS section in RAM with 0 values"}),"\n",(0,r.jsxs)(n.li,{children:["jump to the ",(0,r.jsx)(n.code,{children:"main"})," function and never return."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"the-interrupt_vector-section",children:["The ",(0,r.jsx)(n.code,{children:".interrupt_vector"})," section"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:".interrupt_section"})," is provided by ",(0,r.jsx)(n.code,{children:"rp235x_hal"})," crate (or ",(0,r.jsx)(n.code,{children:"rp2040_hal"})," for the Pico 1).\nImporting this crate is enough to provide a valid interrupt vector."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#![no_std]\n#![no_main]\n\n// we use as _ to avoid a compiler warning\n// saying that the crate is not used\nuse rp235x_hal as _;\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"the-start_block-and-end_blocks",children:["The ",(0,r.jsx)(n.code,{children:".start_block"})," and ",(0,r.jsx)(n.code,{children:".end_block"}),"s"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"rp235x_hal"})," crate provides the valid ",(0,r.jsx)(n.code,{children:".start_block"})," and ",(0,r.jsx)(n.code,{children:".end_block"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use rp235x_hal::block::ImageDef;\n\n#[unsafe(link_section = ".start_block")]\n#[used]\npub static IMAGE_DEF: ImageDef = ImageDef::secure_exe();\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Older Rust versions do not require ",(0,r.jsx)(n.code,{children:"unsafe"})," around the ",(0,r.jsx)(n.code,{children:"link_section"})," attribute."]})}),"\n",(0,r.jsxs)(n.p,{children:["This code creates a static variable ",(0,r.jsx)(n.code,{children:"IMAGE_DEF"})," of type ",(0,r.jsx)(n.code,{children:"ImageDef"})," and places it\nin the ",(0,r.jsx)(n.code,{children:".start_block"})," section, a dedicated section for bootloader\nor secure boot metadata. The ",(0,r.jsx)(n.code,{children:"#[used]"})," attribute ensures the variable is\nincluded in the binary, even if it isn't directly referenced,\nwhich is crucial for secure boot functionality or other boot-related processes."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"secure_exe"})," function creates a ",(0,r.jsx)(n.code,{children:".start_block"})," that instructs the ",(0,r.jsx)(n.code,{children:"BOOTROM"})," of the\nRaspberry Pi Pico 2 to start the firmware in secure execution mode. The processor\nalways starts in secure execution mode and has to be switched to unsecure mode\nby the firmware."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"#[used]"})," attribute is important as linkers will discard code that is\nnot used to lower the size of the binary. The ",(0,r.jsx)(n.code,{children:"IMAGE_DEF"})," variable is not\ndirectly used by anything in the firmware and might be discarded."]})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:".end_block"})," is automatically inserted by the linker using the ",(0,r.jsx)(n.code,{children:"memory.x"})," file."]}),"\n",(0,r.jsxs)(n.h3,{id:"the-main-function",children:["The ",(0,r.jsx)(n.code,{children:"main"})," function"]}),"\n",(0,r.jsxs)(n.p,{children:["When writing software that runs on top of an operating system, the operating system\nis responsible for initializing the memory of the software and the calling\nof the ",(0,r.jsx)(n.code,{children:"main"})," function."]}),"\n",(0,r.jsxs)(n.p,{children:["Embedded firmware that does not run on top of an operating system has to perform the\nmemory initialization tasks and calling the ",(0,r.jsx)(n.code,{children:"main"})," function itself."]}),"\n",(0,r.jsxs)(n.p,{children:["The Rust Embedded Working Group provides a crate called ",(0,r.jsx)(n.code,{children:"cortex_m_rt"})," (",(0,r.jsx)(n.em,{children:"Cortex-M Runtime"}),") that\nexposes the macro ",(0,r.jsx)(n.code,{children:"entry!"})," to perform these tasks. The macro is placed on top of a function\nthat takes no parameters and does no return (",(0,r.jsx)(n.code,{children:"!"}),")."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use cortex_m_rt::entry;\n\n#[entry]\nfn main() -> ! {\n  loop {}\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["The important aspect is the usage of the ",(0,r.jsx)(n.code,{children:"#[entry]"})," macro,\nwhile the name of the function does not need to be ",(0,r.jsx)(n.code,{children:"main"}),"."]})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"entry!"})," macro will rewrite the ",(0,r.jsx)(n.code,{children:"main"})," function and add all the initialization code."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Different frameworks like ",(0,r.jsx)(n.code,{children:"embassy-rs"})," will use different entry macros."]})}),"\n",(0,r.jsx)(n.h2,{id:"flashing-firmware",children:"Flashing firmware"}),"\n",(0,r.jsxs)(n.p,{children:["To run firmware on the Raspberry Pi Pico 2, the\ncompiled program must be transferred to the device's flash (non-volatile) memory. This\nprocess is called ",(0,r.jsx)(n.em,{children:"flashing"}),", and it ensures that the firmware remains on the\ndevice even after a power reset."]}),"\n",(0,r.jsxs)(n.p,{children:["A flashing tool is software that communicates\nwith the device through a debug probe or other interfaces, such as USB or\n",(0,r.jsx)(n.em,{children:"UART"}),", to write the firmware to the correct memory location. Many flashing tools\nalso verify the uploaded firmware to ensure data integrity and provide\nadditional features like chip erasing or memory protection configuration."]}),"\n",(0,r.jsxs)(n.p,{children:["When developing Rust firmware for the Raspberry Pi Pico 2, ",(0,r.jsx)(n.code,{children:"probe-rs"})," is the\npreferred flashing tool to upload and debug code."]}),"\n",(0,r.jsxs)(n.p,{children:["After building the firmware using ",(0,r.jsx)(n.code,{children:"cargo build"}),", an ELF file will be generated in\n",(0,r.jsx)(n.code,{children:"target/thumbv8m.main-none-eabihf/debug/$app_name"}),". This file can be flashed to the\nboard using:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"probe-rs run --chip RP235x target/thumbv8m.main-none-eabihf/debug/$app_name\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Replace $app_name with the name of the firmware's crate, usually the name of the folder\nwhere the firmware source resides."})}),"\n",(0,r.jsxs)(n.h3,{id:"using-cargo-run",children:["Using ",(0,r.jsx)(n.code,{children:"cargo run"})]}),"\n",(0,r.jsxs)(n.p,{children:["On a computer, running a Rust program with ",(0,r.jsx)(n.code,{children:"cargo run"})," compiles the source\ncode into an executable and immediately starts it. This command streamlines\ndevelopment by combining compilation and execution into a single step."]}),"\n",(0,r.jsxs)(n.p,{children:["A similar process applies when using ",(0,r.jsx)(n.code,{children:"cargo run"})," to develop firmware for the Raspberry\nPi Pico 2. Instead of just compiling and running a program on the host computer,\n",(0,r.jsx)(n.code,{children:"cargo run"})," cross compiles the firmware and flashes it onto the target device in one\nstep. Under the hood, it uses ",(0,r.jsx)(n.code,{children:"probe-rs"})," to detect the connected debug probe\nand handle the flashing process automatically. This eliminates the need for\nseparate flashing tools, making firmware development as seamless as running a\nRust program on a computer."]}),"\n",(0,r.jsxs)(n.p,{children:["To be able to use ",(0,r.jsx)(n.code,{children:"cargo run"})," for flashing firmware, a runner has to be specified in the\n",(0,r.jsx)(n.code,{children:".cargo/config.toml"})," file. The following lines have to be added."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'[target.\'cfg(all(target_arch = "arm", target_os = "none"))\']\nrunner = "probe-rs run --chip RP235x"\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Make sure the correct ",(0,r.jsx)(n.code,{children:"[target]"})," is specified in the ",(0,r.jsx)(n.code,{children:".cargo/config.toml"})," configuration file. See the\n",(0,r.jsx)(n.a,{href:"#using-a-configuration-file",children:"cross-compiling"})," section."]})}),"\n",(0,r.jsx)(n.p,{children:"This setup makes flashing firmware to the Raspberry Pi Pico 2 as simple\nas running a Rust program on a computer."}),"\n",(0,r.jsx)(n.h2,{id:"printing-messages",children:"Printing messages"}),"\n",(0,r.jsxs)(n.p,{children:["When developing embedded applications, debugging can be challenging due to\nthe lack of standard output (such as ",(0,r.jsx)(n.code,{children:"println!"}),"). Printed messages need to be generated\non the target device and sent to the host computer\nwhere they are displayed to a console."]}),"\n",(0,r.jsxs)(n.p,{children:["Two common techniques to\nretrieve debug information from an embedded system are ",(0,r.jsx)(n.em,{children:"semihosting"})," and",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.code,{children:"defmt"})}),". Both methods provide insight into program execution but work",(0,r.jsx)(n.br,{}),"\n","differently and are suited for different use cases."]}),"\n",(0,r.jsx)(n.h3,{id:"semihosting",children:"Semihosting"}),"\n",(0,r.jsx)(n.p,{children:"Semihosting is a debugging mechanism that allows an embedded system to\ncommunicate with a host computer via a debugger. It enables operations like:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["printing debug messages (",(0,r.jsx)(n.code,{children:"println!"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"reading input from the host"}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Semihosting requires a hardware debugger."})}),"\n",(0,r.jsx)(n.p,{children:"This works in there steps:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The embedded firmware executes a special ",(0,r.jsx)(n.em,{children:"semihosting instruction"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The debugger software (e.g., ",(0,r.jsx)(n.code,{children:"gdb"})," with ",(0,r.jsx)(n.code,{children:"probe-rs"}),") intercepts the request."]}),"\n",(0,r.jsx)(n.li,{children:"The debugger software processes the request and returns the result to the firmware."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Semihosting is very simple to implement, but has a big drawback, it is slow\nand cannot be used in production."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Printing a panic message takes more than 2 seconds."})}),"\n",(0,r.jsx)(n.h4,{id:"printing-a-message",children:"Printing a message"}),"\n",(0,r.jsxs)(n.p,{children:["Semihosting for Cortex-M is implemented by the ",(0,r.jsx)(n.code,{children:"cortex_m_semihosting"})," crate. This\nexposes the ",(0,r.jsx)(n.code,{children:"hprintln!"}),", a macro used for printing messages to the host system.\nThis macro behaves like ",(0,r.jsx)(n.code,{children:"println!"}),", but instead of\nprinting to the terminal, it sends the output to the debugger, which then\ntransmits it to the host system."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#![no_std]\n#![no_main]\n\nuse cortex_m_rt::entry;\nuse cortex_m_semihosting::hprintln;\n\n#[entry]\nfn main() -> ! {\n  hprintln!("Device has started");\n  // write the rest of the code here\n  loop {}\n}\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"The main advantage of semihosting is that it works with all the embedded frameworks."})}),"\n",(0,r.jsx)(n.h4,{id:"printing-the-panic",children:"Printing the panic"}),"\n",(0,r.jsxs)(n.p,{children:["The Rust language provides a special function called the ",(0,r.jsx)(n.em,{children:"panic handler"})," that gets\ncalled in case things go wrong. For instance attempting to divide to 0 will call the\npanic handler."]}),"\n",(0,r.jsxs)(n.p,{children:["In embedded systems, the ",(0,r.jsx)(n.em,{children:"panic handler"})," is used to handle unexpected runtime errors.",(0,r.jsx)(n.br,{}),"\n","Using ",(0,r.jsx)(n.code,{children:"hprintln!"})," in the panic handler allows developers to print helpful debug",(0,r.jsx)(n.br,{}),"\n","messages when the program encounters a panic, making it easier to solve issues."]}),"\n",(0,r.jsxs)(n.p,{children:["When using ",(0,r.jsx)(n.code,{children:"#![no_std]"}),", developers have to define their own panic handler."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#![no_std]\n#![no_main]\n\nuse cortex_m_rt::entry;\nuse cortex_m_semihosting::hprintln;\nuse core::panic::PanicInfo;\n\n#[entry]\nfn main() -> ! {\n    // Trigger a panic by dividing by zero (for demonstration purposes)\n    let result = divide(23, 0);\n    hprintln!("Result: {}", result);\n\n    loop {}\n}\n\n// Divide the two given numbers\nfn divide(a: u32, b: u32) -> u32 {\n    a / b\n}\n\n// Define the panic handler\n#[panic_handler]\nfn panic(info: &PanicInfo) -> ! {\n    // Print a panic message\n    hprintln!("Panic occurred: {:?}", info);\n\n    // Enter an infinite loop to halt the system after a panic\n    loop {}\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"divide_by_zero"})," function is intentionally written to trigger a panic\n(dividing by zero)."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["the panic_handler is defined using the ",(0,r.jsx)(n.code,{children:"#[panic_handler]"})," attribute, when a panic occurs, this handler will be called;"]}),"\n",(0,r.jsxs)(n.li,{children:["inside the panic_handler, ",(0,r.jsx)(n.code,{children:"hprintln!"})," is used to print the panic message (",(0,r.jsx)(n.code,{children:"Panic occurred: ..."}),") to the host system via semihosting."]}),"\n",(0,r.jsxs)(n.li,{children:["the program enters an infinite loop (",(0,r.jsx)(n.code,{children:"loop {}"}),") to halt the system after a panic, preventing the device from continuing to run."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Panic handlers are usually defined by the frameworks. ",(0,r.jsx)(n.code,{children:"embassy-rs"})," does define its own panic handler."]})}),"\n",(0,r.jsxs)(n.h3,{id:"using-defmt",children:["Using ",(0,r.jsx)(n.code,{children:"defmt"})]}),"\n",(0,r.jsx)(n.p,{children:"Another drawback of semihosting is that\nall the strings used in the debug messages are stored into the firmware's DATA\nsections and are flashed to the device. All the formating of these strings\nis done by the device."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"https://github.com/knurling-rs/defmt",children:(0,r.jsx)(n.code,{children:"defmt"})})," crate is a compact logging framework\ndesigned for Rust-based embedded systems. Its name comes from ",(0,r.jsx)(n.em,{children:"Deferred Formatting"}),". Instead of sending full log messages,\nit transmits compressed binary data, which is later decoded on the host."]}),"\n",(0,r.jsx)(n.p,{children:"This works in two steps:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["the firmware sends compressed log data via a debug probe (e.g., using ",(0,r.jsx)(n.code,{children:"probe-rs"}),") or another transport like UART (serial port);"]}),"\n",(0,r.jsxs)(n.li,{children:["the host tool (",(0,r.jsx)(n.code,{children:"defmt-print"}),") decodes the data and prints human-readable logs."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"defmt"})," implies working with its own printing macros:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"error!"})," used for logging errors, that mean that the firmware cannot conitnue to correctly run;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"warn!"})," used for logging warning messages, that are usually recoverable errors, and the framework can continue to run correctly;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"info!"})," used for logging information messages;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"debug!"})," used for logging debug messages that should not be displayed under normal functioning;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"trace!"})," used for logging almost all the actions of the firmware, messages that should be enabled only when the firmware does not work correctly and needs detailed debugging."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"transports",children:"Transports"}),"\n",(0,r.jsxs)(n.p,{children:["One of the key features of ",(0,r.jsx)(n.code,{children:"defmt"})," is its flexible transport system, allowing developers\nto choose how the log data is transmitted.",(0,r.jsx)(n.br,{}),"\n","Here, we'll highlight ",(0,r.jsx)(n.em,{children:"RTT"})," (",(0,r.jsx)(n.em,{children:"Real-Time Transfer"}),") and ",(0,r.jsx)(n.em,{children:"UART"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"RTT"})," is one of the most powerful transport solutions for embedded debugging.\nIt is a high-speed communication protocol that allows log data to be sent from\nthe embedded system to the host system in real time. RTT works through the\ndebugger's ",(0,r.jsx)(n.em,{children:"SWD"})," (",(0,r.jsx)(n.em,{children:"Serial Wire Debug"}),") interface, which allows communication\nbetween the device and the host without requiring an additional ",(0,r.jsx)(n.em,{children:"UART"})," or ",(0,r.jsx)(n.em,{children:"USB"}),"\nconnection."]}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.em,{children:"RTT"})," requires a debugger."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"RTT"})," has several key advantages over traditional ",(0,r.jsx)(n.em,{children:"UART"}),". It offers much higher\ndata transfer speeds, making it ideal for applications that need frequent\nlog output or high-throughput debugging. Moreover, ",(0,r.jsx)(n.em,{children:"RTT"})," doesn't require a\nseparate serial interface or special drivers on the host system, as the\ndebugger itself handles the communication. The real-time nature of ",(0,r.jsx)(n.em,{children:"RTT"})," is\nperfect for debugging critical, time-sensitive systems."]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"UART"})," is one of the oldest and most commonly used serial communication protocols\nin embedded systems. It\u2019s well-supported by almost every microcontroller and\nplatform, and it provides a straightforward way to send log data to a host system.\nIn the context of ",(0,r.jsx)(n.code,{children:"defmt"}),", ",(0,r.jsx)(n.em,{children:"UART"})," can be used to transmit log data as ASCII or\nbinary over a serial connection, where it is then decoded by a terminal or\nhost application."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["While ",(0,r.jsx)(n.em,{children:"UART"})," is slower than RTT, it remains a popular solution due to its simplicity\nand widespread availability. It can be easily set up on most microcontrollers and\nis supported by many ",(0,r.jsx)(n.em,{children:"USB-to-serial"})," adapters, making it accessible for both\nbeginners and experienced developers. However, it has limitations in terms of\nspeed and real-time debugging capabilities, especially in cases with large log\noutputs or higher data transfer requirements."]})}),"\n",(0,r.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["This example demonstrates how to use ",(0,r.jsx)(n.code,{children:"defmt"})," for logging in an embedded system,\nhandle panics, and send log messages over ",(0,r.jsx)(n.em,{children:"RTT"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#![no_std]\n#![no_main]\n\nuse cortex_m_rt::entry;\nuse defmt::{error, info};\n// use RTT for defmt transport\nuse defmt_rtt as _;\nuse core::panic::PanicInfo;\n\n#[entry]\nfn main() -> ! {\n  info!("Device has started");\n  panic!("panic here");\n}\n\n#[panic_handler]\nfn panic(info: &PanicInfo) -> ! {\n    error!("{:?}", info);\n    loop {}\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"defmt"})," crate is used for logging, and two macros are employed in this example: ",(0,r.jsx)(n.code,{children:"info!"})," and ",(0,r.jsx)(n.code,{children:"error!"}),". The ",(0,r.jsx)(n.code,{children:"info!"})," macro is used to log informational messages, such as when the device starts up. The ",(0,r.jsx)(n.code,{children:"error!"})," macro is used in the panic handler to log error messages if the system encounters a panic.\nThe logging data is transmitted via ",(0,r.jsx)(n.em,{children:"RTT"})," using the ",(0,r.jsx)(n.code,{children:"defmt_rtt"})," crate, which is imported but not explicitly called.\nThe use of RTT enables real-time, high-speed communication between the embedded system and the host,\nmaking it suitable for debugging in time-sensitive applications."]}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.code,{children:"main"})," function, the program begins by logging the message ",(0,r.jsx)(n.code,{children:'"Device has started"'})," with the ",(0,r.jsx)(n.code,{children:"info!"})," macro.\nFollowing this, the ",(0,r.jsx)(n.code,{children:"panic!"})," macro is called, simulating a panic condition. This could be triggered for various\nreasons, such as an unexpected error or failed condition in the embedded system."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"panic handler"})," logs the panic information using the ",(0,r.jsx)(n.code,{children:"error!"})," macro. The ",(0,r.jsx)(n.code,{children:"info"})," parameter passed to the panic handler contains details about the panic, which are logged for debugging purposes.\nAfter logging the error, the program enters an infinite loop (",(0,r.jsx)(n.code,{children:"loop {}"}),") to prevent further execution,\neffectively halting the system in a controlled manner. This is a common pattern in embedded systems when\nhandling critical errors or panics."]}),"\n",(0,r.jsx)(n.h4,{id:"filtering-messages",children:"Filtering messages"}),"\n",(0,r.jsxs)(n.p,{children:["Messages printed by ",(0,r.jsx)(n.code,{children:"defmt"})," can be filetred using the ",(0,r.jsx)(n.code,{children:"DEFMT_LOG"})," environemnt variable. The value\nof this variable represents the lowest priority type of message the will be printed."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Message"}),(0,r.jsx)(n.th,{children:"Priority"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"trace!"})}),(0,r.jsx)(n.td,{children:"0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"debug!"})}),(0,r.jsx)(n.td,{children:"1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"info!"})}),(0,r.jsx)(n.td,{children:"2"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"warn!"})}),(0,r.jsx)(n.td,{children:"3"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"error!"})}),(0,r.jsx)(n.td,{children:"4"})]})]})]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"DEFMT_LOG"})," variable has to be set during the build."]})}),"\n",(0,r.jsxs)(n.p,{children:["To avoid setting this variable at every build, a ",(0,r.jsx)(n.code,{children:".cargo/config.toml"})," entry can be used."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'[env]\nDEFMT_LOG = "debug"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This example will ask ",(0,r.jsx)(n.code,{children:"cargo run"})," to only print messages with a priority higher or equal to ",(0,r.jsx)(n.code,{children:"debug!"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"semihosting-and-defmt",children:["Semihosting and ",(0,r.jsx)(n.code,{children:"defmt"})]}),"\n",(0,r.jsx)(n.p,{children:"This table show the advantages and disadvantages of both methods."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Semihosting"}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"defmt"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.td,{children:"Slow (halts CPU)"}),(0,r.jsx)(n.td,{children:"Fast (minimal overhead)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Output Format"})}),(0,r.jsxs)(n.td,{children:["Plain text (",(0,r.jsx)(n.code,{children:"hprintln!"}),")"]}),(0,r.jsx)(n.td,{children:"Compressed binary logs"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Debugger Required?"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No (can use other transports)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Memory Usage"})}),(0,r.jsx)(n.td,{children:"High (standard Rust formatting)"}),(0,r.jsx)(n.td,{children:"Low (compact binary format)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Use Case"})}),(0,r.jsx)(n.td,{children:"Debugging with full text output"}),(0,r.jsx)(n.td,{children:"Real-time logging on embedded devices"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Create a new project using ",(0,r.jsx)(n.code,{children:"cargo init"}),". Configure the project using a configuration file\nto build for the lab board's target. Test it by running ",(0,r.jsx)(n.code,{children:"cargo build"}),". Take a look at ",(0,r.jsx)(n.a,{href:"#cross-compiling",children:"Cross-compiling"}),"(",(0,r.jsx)(n.strong,{children:"1p"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["All you have to do is to make sure you are building a binary that does not depend on ",(0,r.jsx)(n.code,{children:"std"}),", has no ",(0,r.jsx)(n.code,{children:"main"})," function\nand provides an ",(0,r.jsx)(n.strong,{children:"empty panic handler"}),"."]}),(0,r.jsxs)(n.p,{children:["To prevent ",(0,r.jsx)(n.code,{children:"rust-analyzer"})," from showing an error on the first line and to automatically\nformat your source when saving, create a ",(0,r.jsx)(n.code,{children:".vscode/settings.json"})," file with:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "rust-analyzer.cargo.allTargets": false,\n    "[rust]": {\n        "editor.defaultFormatter": "rust-lang.rust-analyzer",\n        "editor.formatOnSave": true,\n        "editor.formatOnSaveMode": "file",\n    },\n}\n'})})]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["Inspect the binary and figure out what sections are missing. Explain why each of the sections\nis missing. take a look at ",(0,r.jsx)(n.a,{href:"#inspect-binaries",children:"Inspect binaries"}),". (",(0,r.jsx)(n.strong,{children:"1p"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Add the ",(0,r.jsx)(n.code,{children:"cortex-m-rt"})," crate to your project and define a\nfunction as an ",(0,r.jsx)(n.em,{children:"entry point"})," for your firmware. Inspect the binary and see which of the required sections are present. (",(0,r.jsx)(n.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"cargo add"})," command adds crates to a project."]})}),"\n",(0,r.jsxs)(n.ol,{start:"4",children:["\n",(0,r.jsxs)(n.li,{children:["Write a linker script to add the correct sections to your binary.\nTake a look at ",(0,r.jsx)(n.a,{href:"#linker-script",children:"Linker script"}),". Inspect the binary and check if the\nrequired sections are present. (",(0,r.jsx)(n.strong,{children:"1p"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Write the build script to instruct the linker to use the linker script. Take a look at ",(0,r.jsx)(n.a,{href:"#build-script",children:"Build script"}),".\nInspect the binary and see if the required sections are present. Is one of the sections missing? (",(0,r.jsx)(n.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Make sure that the build script only uses linker scripts that exist in the project.\nSome crates, like ",(0,r.jsx)(n.code,{children:"cortex-m-rt"})," and ",(0,r.jsx)(n.code,{children:"defmt"})," provide linker scripts."]})}),"\n",(0,r.jsxs)(n.ol,{start:"6",children:["\n",(0,r.jsxs)(n.li,{children:["Print a message from the main function using semihosting. Try running\nthe firmware using ",(0,r.jsx)(n.code,{children:"probe-rs run target/...$app_name"}),". Why doesn't it work? Take a look at ",(0,r.jsx)(n.a,{href:"#semihosting",children:"Semihosting"})," (",(0,r.jsx)(n.strong,{children:"1p"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Add the ",(0,r.jsx)(n.code,{children:"rp235x_hal"})," crate to the project and configure the ",(0,r.jsx)(n.code,{children:".start_block"})," and the ",(0,r.jsx)(n.code,{children:".end_block"}),". Take\na look at ",(0,r.jsxs)(n.a,{href:"#the-start_block-and-end_blocks",children:["The ",(0,r.jsx)(n.code,{children:".start_block"})," and ",(0,r.jsx)(n.code,{children:".end_block"})]}),". (",(0,r.jsx)(n.strong,{children:"1p"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Use semihosting to print the panic message in the ",(0,r.jsx)(n.em,{children:"panic handler"}),". Use the ",(0,r.jsx)(n.code,{children:"panic!"})," macro to\ngenerate a panic. Take a look at ",(0,r.jsx)(n.a,{href:"#printing-the-panic",children:"Printing the panic"})," (",(0,r.jsx)(n.strong,{children:"1p"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Use the ",(0,r.jsx)(n.code,{children:"defmt"})," and ",(0,r.jsx)(n.code,{children:"defmt_rtt"})," crates to print ",(0,r.jsx)(n.code,{children:"info!"})," and ",(0,r.jsx)(n.code,{children:"error!"})," messages. Generate a panic to verify the error message.\nTake a look at ",(0,r.jsxs)(n.a,{href:"#using-defmt",children:["Using ",(0,r.jsx)(n.code,{children:"defmt"})]})," (",(0,r.jsx)(n.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Make sure you add all the necessary linker scripts to the ",(0,r.jsx)(n.code,{children:"build.rs"})," build script."]}),"\n",(0,r.jsxs)(n.li,{children:["Make sure you enable the ",(0,r.jsx)(n.code,{children:"defmt"})," and ",(0,r.jsx)(n.code,{children:"critical-section-impl"})," features of the ",(0,r.jsx)(n.code,{children:"rp235x_hal"})," crate (",(0,r.jsx)(n.code,{children:"cargo add --features"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Make sure you set the ",(0,r.jsx)(n.code,{children:"DEFMT_LOG"})," variable to ",(0,r.jsx)(n.code,{children:"info"})," when building to see the ",(0,r.jsx)(n.code,{children:"info"})," messages or\nuse the ",(0,r.jsx)(n.code,{children:".cargo/config.toml"})," file (take a look at ",(0,r.jsx)(n.a,{href:"#filtering-messages",children:"Filtering Messages"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Messages are printed together with the location where the message was issued. To supress this\nuse the ",(0,r.jsx)(n.code,{children:" --no-location"})," parameter for ",(0,r.jsx)(n.code,{children:"probe-rs run"}),"."]}),"\n"]})}),"\n",(0,r.jsxs)(n.ol,{start:"10",children:["\n",(0,r.jsxs)(n.li,{children:["Use the ",(0,r.jsx)(n.code,{children:"panic-probe"})," crate to display better panics. (",(0,r.jsx)(n.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This crate provides a panic handler."}),"\n",(0,r.jsxs)(n.li,{children:["Enable the ",(0,r.jsx)(n.code,{children:"print-defmt"})," features of ",(0,r.jsx)(n.code,{children:"panic-probe"})," to use ",(0,r.jsx)(n.code,{children:"defmt"})," to print panics."]}),"\n"]})}),"\n",(0,r.jsxs)(n.ol,{start:"11",children:["\n",(0,r.jsxs)(n.li,{children:["Make the necessary configuration so that you can use ",(0,r.jsx)(n.code,{children:"cargo run"})," to flash the firmware. Take a look\nat ",(0,r.jsxs)(n.a,{href:"#using-cargo-run",children:["Using ",(0,r.jsx)(n.code,{children:"cargo run"})]})," (",(0,r.jsx)(n.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["You can add the ",(0,r.jsx)(n.code,{children:"--no-location"})," parameter to the runner."]})}),"\n",(0,r.jsx)(n.h2,{id:"vs-code-probe-rs-extension",children:"VS Code probe-rs Extension"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsxs)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=probe-rs.probe-rs-debugger",children:[(0,r.jsx)(n.code,{children:"probe-rs"})," extension for ",(0,r.jsx)(n.em,{children:"Visual Studio Code"})]})," is a powerful tool designed to streamline\nthe development and debugging of embedded Rust applications. It provides a seamless experience\nfor flashing firmware, setting breakpoints, and inspecting memory on embedded devices,\nincluding the Raspberry Pi Pico 1 and Pico 2. By integrating with ",(0,r.jsx)(n.code,{children:"probe-rs"}),", this extension\nremoves the complexity of configuring traditional debugging setups that rely on ",(0,r.jsx)(n.em,{children:"GDB"})," and ",(0,r.jsx)(n.em,{children:"OpenOCD"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"probe-rs"})," within ",(0,r.jsx)(n.em,{children:"VS Code"})," greatly simplifies the debugging workflow. Instead of manually\ninvoking command-line tools to flash firmware and debug, users can configure the extension via a\nsimple ",(0,r.jsx)(n.code,{children:"launch.json"})," file. This configuration specifies the target chip, the firmware binary\nto flash, and debugging options. Once set up, developers can start debugging with a\nsingle click or by pressing ",(0,r.jsx)(n.code,{children:"F5"}),", making the process efficient and user-friendly."]}),"\n",(0,r.jsxs)(n.p,{children:["It integrates natively with ",(0,r.jsx)(n.code,{children:"defmt"}),", allowing developers to view structured log messages\ndirectly within VS Code\u2019s terminal. This is especially useful for debugging\napplications running on resource-constrained devices like the Raspberry Pi Pico 1 and Pico 2,\nwhere traditional logging methods may be impractical."]}),"\n",(0,r.jsxs)(n.h3,{id:"set-up-launchjson",children:["Set up ",(0,r.jsx)(n.code,{children:"launch.json"})]}),"\n",(0,r.jsxs)(n.p,{children:["VS Code's ",(0,r.jsx)(n.code,{children:"probe-rs"})," extension uses a configuration file called ",(0,r.jsx)(n.code,{children:"launch.json"})," located in the\n",(0,r.jsx)(n.code,{children:".vscode"})," folder of the project."]}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(a.A,{value:"rp2350",label:"Raspberry Pi Pico 2",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "preLaunchTask": "rust: cargo build",\n            "type": "probe-rs-debug",\n            "request": "launch",\n            "name": "Raspberry Pi Pico 2",\n            "cwd": "${workspaceFolder}",\n            "connectUnderReset": false,\n            "chip": "RP235x",\n            "flashingConfig": {\n                "flashingEnabled": true,\n                "haltAfterReset": false,\n            },\n            "coreConfigs": [\n                {\n                    "coreIndex": 0,\n                    "programBinary": "./target/thumbv8m.main-none-eabihf/debug/${workspaceFolderBasename}",\n                    "svdFile": "./rp2350.svd",\n                    "rttEnabled": true,\n                }\n            ]\n        }\n    ]\n}\n'})})}),(0,r.jsx)(a.A,{value:"rp2040",label:"Raspberry Pi Pico",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "preLaunchTask": "rust: cargo build",\n            "type": "probe-rs-debug",\n            "request": "launch",\n            "name": "Raspberry Pi Pico",\n            "cwd": "${workspaceFolder}",\n            "connectUnderReset": false,\n            "chip": "RP2040",\n            "flashingConfig": {\n                "flashingEnabled": true,\n                "haltAfterReset": false,\n            },\n            "coreConfigs": [\n                {\n                    "coreIndex": 0,\n                    "programBinary": "./target/thumbv6m-none-eabi/debug/${workspaceFolderBasename}",\n                    "svdFile": "./rp2040.svd",\n                    "rttEnabled": true,\n                }\n            ]\n        }\n    ]\n}\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["This ",(0,r.jsx)(n.code,{children:"launch.json"})," file configures VS Code's ",(0,r.jsx)(n.code,{children:"probe-rs"})," extension for debugging\nfirmware on the Raspberry Pi Pico. It defines how the debugger interacts\nwith the ",(0,r.jsx)(n.code,{children:"RP235x"})," or the ",(0,r.jsx)(n.code,{children:"RP2040"})," chip, including ",(0,r.jsx)(n.em,{children:"flashing"}),", ",(0,r.jsx)(n.em,{children:"RTT support"}),", and the\n",(0,r.jsx)(n.em,{children:"firmware's location"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:'"version": "0.2.0"'})," field specifies the configuration format. The\n",(0,r.jsx)(n.code,{children:'"configurations"'})," array holds debug settings, with a single configuration\nfor the Pico."]}),"\n",(0,r.jsxs)(n.p,{children:["Before debugging, ",(0,r.jsx)(n.code,{children:'"preLaunchTask": "rust: cargo build"'})," ensures the firmware\nis compiled. The ",(0,r.jsx)(n.code,{children:'"type": "probe-rs-debug"'})," field tells ",(0,r.jsx)(n.em,{children:"VS Code"})," to use\n",(0,r.jsx)(n.code,{children:"probe-rs"})," as the debug backend. The ",(0,r.jsx)(n.code,{children:'"request": "launch"'})," mode starts a\nnew debugging session. The ",(0,r.jsx)(n.code,{children:'"name"'})," field labels this configuration."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:'"cwd": "${workspaceFolder}"'})," sets the working directory to the project\nroot. The ",(0,r.jsx)(n.code,{children:'"connectUnderReset": false'})," prevents connecting while the device\nis held in reset. The ",(0,r.jsx)(n.code,{children:'"chip": "RP235x"'})," or ",(0,r.jsx)(n.code,{children:'"chip": "RP2040"'})," tells probe-rs which microcontroller",(0,r.jsx)(n.br,{}),"\n","is in use."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:'"flashingConfig"'})," section controls how firmware is written to flash.\nWith ",(0,r.jsx)(n.code,{children:'"flashingEnabled": true'}),", the firmware is flashed before debugging.\nThe ",(0,r.jsx)(n.code,{children:'"haltAfterReset": false'})," allows execution to continue after reset."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"coreConfigs"})," array defines how individual CPU cores are handled. Since\nRP235x has multiple cores, this example configures ",(0,r.jsx)(n.strong,{children:"core 0"}),". The firmware\nbinary is loaded from ",(0,r.jsx)(n.code,{children:"./target/thumbv8m.main-none-eabihf/debug/${workspaceFolderBasename}"}),".\nThe ",(0,r.jsx)(n.code,{children:'"svdFile": "./rp2350.svd"'})," provides ",(0,r.jsx)(n.strong,{children:"register descriptions"})," for\ndebugging."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:'"rttEnabled": true"'})," setting enables ",(0,r.jsx)(n.strong,{children:"Real-Time Transfer (RTT)"}),",\nallowing debug output to be streamed efficiently without interfering with\nprogram execution. This is used for reading the messages sent by ",(0,r.jsx)(n.code,{children:"defmt"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"running-the-firmware",children:"Running the firmware"}),"\n",(0,r.jsxs)(n.p,{children:["This is how the ",(0,r.jsx)(n.code,{children:"probe-rs"})," extension for ",(0,r.jsx)(n.em,{children:"VS Code"})," UI looks like when\ndebugging firmware."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"probe-rs VSCode extension",src:i(40562).A+"",width:"2380",height:"1556"})}),"\n",(0,r.jsxs)(n.p,{children:["To run firmware on the Raspberry Pi Pico 1 or 2 using the ",(0,r.jsx)(n.code,{children:"probe-rs"})," extension\nin ",(0,r.jsx)(n.em,{children:"Visual Studio Code"}),", open your project and ensure your ",(0,r.jsx)(n.code,{children:"launch.json"}),"\nfile is ",(0,r.jsx)(n.a,{href:"#set-up-launchjson",children:"correctly configured"}),". Before starting, connect\nyour ",(0,r.jsx)(n.em,{children:"debugger"}),"* to the Pico and power the board."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"If you are using the lab board, please make sure you are using the USB-C connector."})}),"\n",(0,r.jsx)(n.h4,{id:"starting-the-debugging-session",children:"Starting the Debugging Session"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Open the ",(0,r.jsx)(n.strong,{children:"Run and Debug"})," panel in VS Code by clicking the ",(0,r.jsx)(n.strong,{children:"Run"})," icon",(0,r.jsx)(n.br,{}),"\n","in the left sidebar or pressing ",(0,r.jsx)(n.code,{children:"Ctrl+Shift+D"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Select ",(0,r.jsx)(n.em,{children:'"Raspberry Pi Pico 2"'})," (or the name of your configuration) from",(0,r.jsx)(n.br,{}),"\n","the drop-down menu at the top of the panel."]}),"\n",(0,r.jsxs)(n.li,{children:["Click the ",(0,r.jsx)(n.strong,{children:"Start Debugging"})," button (",(0,r.jsx)("span",{style:{color:"green"},children:"\u25b6"}),"), or press ",(0,r.jsx)(n.code,{children:"F5"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The firmware will be flashed automatically if ",(0,r.jsx)(n.code,{children:'"flashingEnabled": true'})," is\nset in ",(0,r.jsx)(n.code,{children:"launch.json"}),". Once the process completes, execution starts, and the\ndebugger attaches to the target."]}),"\n",(0,r.jsx)(n.h4,{id:"checking-for-errors-and-debug-output",children:"Checking for Errors and Debug Output"}),"\n",(0,r.jsxs)(n.p,{children:["If something goes wrong, look for errors in the ",(0,r.jsx)(n.strong,{children:"PROBLEMS"})," tab at the\nbottom of ",(0,r.jsx)(n.em,{children:"VS Code"}),". If flashing fails, check the ",(0,r.jsx)(n.strong,{children:"TERMINAL"})," or ",(0,r.jsx)(n.strong,{children:"DEBUG\nCONSOLE"})," for ",(0,r.jsx)(n.code,{children:"probe-rs"})," messages. Common issues include:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.em,{children:"debug probe is not detected"}),". Try reconnecting the hardware."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.em,{children:"Pico is not powered on"}),". Ensure proper connections."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Flashing errors"})," due to a missing or corrupted firmware binary."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If using ",(0,r.jsx)(n.code,{children:"defmt"})," for logging, open the ",(0,r.jsx)(n.strong,{children:"TERMINAL"})," to see formatted\ndebug messages. If ",(0,r.jsx)(n.em,{children:"RTT"})," is enabled (",(0,r.jsx)(n.code,{children:'"rttEnabled": true'}),"), ",(0,r.jsx)(n.code,{children:"defmt"})," output will\nstream here in real-time."]}),"\n",(0,r.jsx)(n.h4,{id:"stopping-the-running-firmware",children:"Stopping the Running Firmware"}),"\n",(0,r.jsxs)(n.p,{children:["To stop execution, press the ",(0,r.jsx)(n.strong,{children:"Stop Debugging"})," button (",(0,r.jsx)("span",{style:{color:"orange"},children:"\u25a0"}),") in the debug\ntoolbar or use the shortcut ",(0,r.jsx)(n.code,{children:"Shift+F5"}),". This halts the processor and\ndisconnects the debugger. If the device is still running after stopping,\nyou may need to ",(0,r.jsx)(n.strong,{children:"power-cycle"})," the Pico to fully reset it."]}),"\n",(0,r.jsx)(n.h3,{id:"using-breakpoints",children:"Using Breakpoints"}),"\n",(0,r.jsxs)(n.p,{children:["When debugging firmware on the Raspberry Pi Pico 1 and 2 using the ",(0,r.jsx)(n.code,{children:"probe-rs"}),"\nextension in ",(0,r.jsx)(n.em,{children:"Visual Studio Code"}),", breakpoints allow you to pause execution\nat specific lines of code, while stepping lets you ",(0,r.jsx)(n.em,{children:"move through code\nline-by-line"})," to inspect its behavior."]}),"\n",(0,r.jsx)(n.h4,{id:"placing-a-breakpoint",children:"Placing a Breakpoint"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Open the Rust source file you want to debug."}),"\n",(0,r.jsxs)(n.li,{children:["Click in the ",(0,r.jsx)(n.strong,{children:"gutter"})," (left margin) next to a line of code where you\nwant execution to pause. A ",(0,r.jsx)(n.strong,{children:"red dot"})," will appear, indicating an\n",(0,r.jsx)(n.strong,{children:"active breakpoint"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Alternatively, place the cursor on a line and press ",(0,r.jsx)(n.code,{children:"F9"})," to toggle a\nbreakpoint."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Breakpoints are ",(0,r.jsx)(n.strong,{children:"only effective in code that is actually executed"}),". If a\nbreakpoint is placed on an unused function, it will be ignored."]}),"\n",(0,r.jsx)(n.h4,{id:"starting-and-hitting-a-breakpoint",children:"Starting and Hitting a Breakpoint"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Start debugging with ",(0,r.jsx)(n.code,{children:"F5"})," (or the ",(0,r.jsx)(n.strong,{children:"Start Debugging"})," button in the\n",(0,r.jsx)(n.strong,{children:"Run and Debug"})," panel)."]}),"\n",(0,r.jsxs)(n.li,{children:["When execution reaches a breakpoint, the program ",(0,r.jsx)(n.strong,{children:"pauses"})," at that\nline, allowing you to inspect variables and memory."]}),"\n",(0,r.jsxs)(n.li,{children:["Hover over variables to see their values or use the ",(0,r.jsx)(n.strong,{children:"Variables"}),"\npanel in the Debug sidebar."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"stepping-through-code",children:"Stepping Through Code"}),"\n",(0,r.jsxs)(n.p,{children:["When a breakpoint is hit, you can control execution using the ",(0,r.jsx)(n.strong,{children:"Debug Toolbar"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Step Over (",(0,r.jsx)(n.code,{children:"F10"}),")"]})," \u2192 Executes the current line and moves to the next.\nIf the line contains a function call, the function runs but isn\u2019t entered."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Step Into (",(0,r.jsx)(n.code,{children:"F11"}),")"]})," \u2192 Enters a function call to debug inside it."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Step Out (",(0,r.jsx)(n.code,{children:"Shift+F11"}),")"]})," \u2192 Runs until the current function returns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Continue (",(0,r.jsx)(n.code,{children:"F5"}),")"]})," \u2192 Resumes execution until the next breakpoint or",(0,r.jsx)(n.br,{}),"\n","program end."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"removing-or-disabling-breakpoints",children:"Removing or Disabling Breakpoints"}),"\n",(0,r.jsxs)(n.p,{children:["To remove a breakpoint, click the ",(0,r.jsx)(n.strong,{children:"red dot"})," again or press ",(0,r.jsx)(n.code,{children:"F9"})," on the\nselected line. To temporarily disable a breakpoint, right-click it and\nselect ",(0,r.jsx)(n.strong,{children:"Disable Breakpoint"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Using breakpoints and stepping makes it easier to understand how firmware\nexecutes and diagnose issues efficiently in ",(0,r.jsx)(n.code,{children:"probe-rs"})," with VS Code."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"probe-rs VS Code extension debug",src:i(85043).A+"",width:"2380",height:"1556"})}),"\n",(0,r.jsx)(n.h3,{id:"watches",children:"Watches"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"probe-rs"})," extension in ",(0,r.jsx)(n.em,{children:"VS Code"})," provides powerful debugging tools",(0,r.jsx)(n.br,{}),"\n","to inspect variables, function execution, and hardware registers while\ndeveloping firmware for the Raspberry Pi Pico 2."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"WATCH"})," panel in VS Code allows developers to track specific\nvariables and expressions while debugging. This is useful for monitoring\nregister values, checking memory locations, and debugging complex logic."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Start debugging (",(0,r.jsx)(n.code,{children:"F5"}),") and hit a ",(0,r.jsx)(n.strong,{children:"breakpoint"})," where you want to inspect\nvariables."]}),"\n",(0,r.jsxs)(n.li,{children:["Open the ",(0,r.jsx)(n.strong,{children:"WATCH"})," panel in the Debug sidebar."]}),"\n",(0,r.jsxs)(n.li,{children:["Click ",(0,r.jsx)(n.strong,{children:'"Add Expression"'})," and enter a variable name or memory address.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Example: ",(0,r.jsx)(n.code,{children:"some_variable"})," (for normal variables)."]}),"\n",(0,r.jsxs)(n.li,{children:["Example: ",(0,r.jsx)(n.code,{children:"*(0xD0000014 as *const u32)"})," (to read a register)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"The expression updates each time the debugger stops."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"call-stack-tracing-function-execution",children:"Call Stack: Tracing Function Execution"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"CALL STACK"})," panel shows the sequence of function calls that led to",(0,r.jsx)(n.br,{}),"\n","the current execution point. This is essential for understanding how the",(0,r.jsx)(n.br,{}),"\n","program reached a specific line of code."]}),"\n",(0,r.jsx)(n.h4,{id:"how-to-use-the-call-stack",children:"How to Use the Call Stack"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["When execution stops at a breakpoint, check the ",(0,r.jsx)(n.strong,{children:"CALL STACK"})," panel."]}),"\n",(0,r.jsxs)(n.li,{children:["The top function is the ",(0,r.jsx)(n.strong,{children:"currently executing function"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Clicking on any function in the stack navigates to its source."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"why-use-the-call-stack",children:"Why Use the Call Stack?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Understand ",(0,r.jsx)(n.strong,{children:"nested function calls"})," (e.g., deep function recursion)."]}),"\n",(0,r.jsxs)(n.li,{children:["Debug ",(0,r.jsx)(n.strong,{children:"unexpected behavior"})," by seeing which path the code took."]}),"\n",(0,r.jsxs)(n.li,{children:["Find where a ",(0,r.jsx)(n.strong,{children:"panic"})," originated in case of a crash."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"peripherals-inspecting-hardware-registers",children:"Peripherals: Inspecting Hardware Registers"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Peripherals"})," panel lets you inspect hardware registers based on\nthe ",(0,r.jsx)(n.strong,{children:"SVD (System View Description) file"})," for the ",(0,r.jsx)(n.strong,{children:"RP235x"})," or ",(0,r.jsx)(n.strong,{children:"RP2040"})," chip. This\nallows direct observation of GPIO states, timers, UART, and more."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"Please make sure that the project folder contains the correct SVD file."})}),"\n",(0,r.jsx)(n.h4,{id:"svd-files-for-the-raspberry-pi-pico",children:"SVD Files for The Raspberry Pi Pico"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Processor"}),(0,r.jsx)(n.th,{children:"Crate that provides the SVD File"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"RP2350"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"https://github.com/rp-rs/rp235x-pac/tree/main/svd",children:"rp235x_pac"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"RP2040"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"https://github.com/rp-rs/rp2040-pac/tree/main/svd",children:"rp2040_pac"})})]})]})]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Make sure you download the ",(0,r.jsx)(n.code,{children:".pacthed"})," versions of the files."]})}),"\n",(0,r.jsx)(n.h4,{id:"how-to-enable-peripheral-debugging",children:"How to Enable Peripheral Debugging"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Ensure ",(0,r.jsx)(n.code,{children:'"svdFile": "./rp2350.svd"'})," or ",(0,r.jsx)(n.code,{children:'"svdFile": "./rp2040.svd"'})," is set in ",(0,r.jsx)(n.code,{children:"launch.json"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Start debugging and hit a ",(0,r.jsx)(n.strong,{children:"breakpoint"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Open the ",(0,r.jsx)(n.strong,{children:"Peripherals"})," panel in the Debug sidebar."]}),"\n",(0,r.jsxs)(n.li,{children:["Expand peripheral groups (e.g., ",(0,r.jsx)(n.code,{children:"GPIO"}),", ",(0,r.jsx)(n.code,{children:"TIMER"}),", ",(0,r.jsx)(n.code,{children:"UART"}),") to see\nlive register values."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"why-use-the-peripherals-panel",children:(0,r.jsx)(n.strong,{children:"Why Use the Peripherals Panel?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Observe ",(0,r.jsx)(n.strong,{children:"hardware state changes"})," while stepping through code."]}),"\n",(0,r.jsxs)(n.li,{children:["Debug ",(0,r.jsx)(n.strong,{children:"GPIO settings, clock configurations, and interrupts"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Avoid manual memory reads by using ",(0,r.jsx)(n.strong,{children:"structured register views"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"extra-exercises",children:"Extra exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Setup the ",(0,r.jsx)(n.code,{children:"probe-rs"})," VS Code Extension to run the firmare directly from ",(0,r.jsx)(n.em,{children:"Visual Studio Code"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Define a few variables throughout the firmware and perform some math. Use the ",(0,r.jsx)(n.code,{children:"probe-rs"})," VS Code extension\nto go step by step throughout the running firmware and look at the variables using the ",(0,r.jsx)(n.strong,{children:"Watches"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Define a few fuctions throughout the firmware and perform some math. Use the ",(0,r.jsx)(n.code,{children:"probe-rs"})," VS Code extension\nto go step by step through the running firmware and look at the called functions using the ",(0,r.jsx)(n.strong,{children:"Call Stack"}),"."]}),"\n"]}),"\n","\n",(0,r.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,r.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{id:"user-content-fn-firmware",children:["\n",(0,r.jsxs)(n.p,{children:["Software that is running on microcontrollers is usually called ",(0,r.jsx)(n.em,{children:"firmware"}),". The words is a combination of the words ",(0,r.jsx)(n.em,{children:"firm"})," and ",(0,r.jsx)(n.em,{children:"software"})," and means the software that the vendor firm of the device has uploaded. ",(0,r.jsx)(n.a,{href:"#user-content-fnref-firmware","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},79329:(e,n,i)=>{i.d(n,{A:()=>o});i(96540);var s=i(34164);const r={tabItem:"tabItem_Ymn6"};var t=i(74848);function o(e){let{children:n,hidden:i,className:o}=e;return(0,t.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,o),hidden:i,children:n})}},65537:(e,n,i)=>{i.d(n,{A:()=>w});var s=i(96540),r=i(34164),t=i(65627),o=i(56347),a=i(50372),d=i(30604),l=i(11861),c=i(78749);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:i}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:i,attributes:s,default:r}}=e;return{value:n,label:i,attributes:s,default:r}}))}(i);return function(e){const n=(0,l.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function p(e){let{value:n,tabValues:i}=e;return i.some((e=>e.value===n))}function x(e){let{queryString:n=!1,groupId:i}=e;const r=(0,o.W6)(),t=function(e){let{queryString:n=!1,groupId:i}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:n,groupId:i});return[(0,d.aZ)(t),(0,s.useCallback)((e=>{if(!t)return;const n=new URLSearchParams(r.location.search);n.set(t,e),r.replace({...r.location,search:n.toString()})}),[t,r])]}function g(e){const{defaultValue:n,queryString:i=!1,groupId:r}=e,t=u(e),[o,d]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=i.find((e=>e.default))??i[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:t}))),[l,h]=x({queryString:i,groupId:r}),[g,m]=function(e){let{groupId:n}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(n),[r,t]=(0,c.Dv)(i);return[r,(0,s.useCallback)((e=>{i&&t.set(e)}),[i,t])]}({groupId:r}),j=(()=>{const e=l??g;return p({value:e,tabValues:t})?e:null})();(0,a.A)((()=>{j&&d(j)}),[j]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:t}))throw new Error(`Can't select invalid tab value=${e}`);d(e),h(e),m(e)}),[h,m,t]),tabValues:t}}var m=i(9136);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=i(74848);function b(e){let{className:n,block:i,selectedValue:s,selectValue:o,tabValues:a}=e;const d=[],{blockElementScrollPositionUntilNextRender:l}=(0,t.a_)(),c=e=>{const n=e.currentTarget,i=d.indexOf(n),r=a[i].value;r!==s&&(l(n),o(r))},h=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const i=d.indexOf(e.currentTarget)+1;n=d[i]??d[0];break}case"ArrowLeft":{const i=d.indexOf(e.currentTarget)-1;n=d[i]??d[d.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":i},n),children:a.map((e=>{let{value:n,label:i,attributes:t}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>{d.push(e)},onKeyDown:h,onClick:c,...t,className:(0,r.A)("tabs__item",j.tabItem,t?.className,{"tabs__item--active":s===n}),children:i??n},n)}))})}function v(e){let{lazy:n,children:i,selectedValue:t}=e;const o=(Array.isArray(i)?i:[i]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===t));return e?(0,s.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function y(e){const n=g(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",j.tabList),children:[(0,f.jsx)(b,{...n,...e}),(0,f.jsx)(v,{...n,...e})]})}function w(e){const n=(0,m.A)();return(0,f.jsx)(y,{...e,children:h(e.children)},String(n))}},76958:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/pico_debug-c81011548c65e602cea6222ddbe69097.webp"},85043:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/probe_rs_debug-31f94da4e6546286fb855091f4bdcb22.webp"},40562:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/probe_rs_vscode-8f0dd60a4e0305f19b7ca9ef6a37cc9f.webp"},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(96540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);