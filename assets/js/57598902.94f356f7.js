"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[530],{50778:(e,s,n)=>{n.r(s),n.d(s,{ElectronicsTutorial:()=>l,assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"lab/02/index","title":"02 - GPIO","description":"General Purpose Input and Output using the Embassy Framework","source":"@site/versioned_docs/version-acs_cc/lab/02/index.mdx","sourceDirName":"lab/02","slug":"/lab/02","permalink":"/docs/acs_cc/lab/02","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/lab/02/index.mdx","tags":[],"version":"acs_cc","frontMatter":{"description":"General Purpose Input and Output using the Embassy Framework","slug":"/lab/02"},"sidebar":"tutorialSidebar","previous":{"title":"01 - Debug","permalink":"/docs/acs_cc/lab/01"},"next":{"title":"03 - PWM & ADC","permalink":"/docs/acs_cc/lab/03"}}');var t=n(74848),r=n(28453),d=n(56942);const a={description:"General Purpose Input and Output using the Embassy Framework",slug:"/lab/02"},o="02 - GPIO",c={};function l({title:e,anchor:s}){const n=(0,d.ir)();return(0,t.jsx)("a",{href:`/docs/${n?.name}/tutorial/electronics${s?"#"+s:""}`,children:e||"Electronics"})}const h=[{value:"Concepts",id:"concepts",level:2},{value:"Resources",id:"resources",level:2},{value:"Extra Resources",id:"extra-resources",level:3},{value:"What is GPIO?",id:"what-is-gpio",level:2},{value:"Configuring GPIO Pins",id:"configuring-gpio-pins",level:2},{value:"Hardware access",id:"hardware-access",level:2},{value:"Embassy Framework",id:"embassy-framework",level:2},{value:"The Software Stack",id:"the-software-stack",level:3},{value:"<em>Empty</em> Embassy Firmware",id:"empty-embassy-firmware",level:3},{value:"Entry",id:"entry",level:3},{value:"Configure GPIO Output",id:"configure-gpio-output",level:3},{value:"Configure GPIO Input",id:"configure-gpio-input",level:3},{value:"Waiting for GPIO Input",id:"waiting-for-gpio-input",level:3},{value:"Waiting",id:"waiting",level:3},{value:"The lab board",id:"the-lab-board",level:2},{value:"Wiring",id:"wiring",level:3},{value:"Raspberry Pi Pico Pins",id:"raspberry-pi-pico-pins",level:3},{value:"LEDs and Switches",id:"leds-and-switches",level:3},{value:"Example",id:"example",level:3},{value:"Exercises",id:"exercises",level:2}];function p(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"02---gpio",children:"02 - GPIO"})}),"\n","\n","\n",(0,t.jsxs)(s.p,{children:["The purpose of this lab is to understand how to start developing firmware in ",(0,t.jsx)(s.a,{href:"https://www.rust-lang.org/",children:"Rust"}),"\nwith ",(0,t.jsx)(s.a,{href:"https://embassy.dev",children:"Embassy"})," for the RP2350 MCU."]}),"\n",(0,t.jsx)(s.h2,{id:"concepts",children:"Concepts"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"How to setup an empty project that uses Embassy;"}),"\n",(0,t.jsx)(s.li,{children:"How to use the lab board;"}),"\n",(0,t.jsx)(s.li,{children:"How to use GPIO pins from Embassy;"}),"\n",(0,t.jsx)(s.li,{children:"How to use the lab board's LEDs"}),"\n",(0,t.jsx)(s.li,{children:"How to use the lab board's switches"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"resources",children:"Resources"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:(0,t.jsx)(s.a,{href:"https://embassy.dev/book/",children:"Embassy Book"})})," - an overview of the ",(0,t.jsx)(s.em,{children:"Embassy"})," framework","\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.em,{children:"For Beginners"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:(0,t.jsxs)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html",children:[(0,t.jsx)(s.code,{children:"embassy-rp"}),"'s Documentation"]})})," - the API for the RP2040 and RP2350"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"The Rusty Bits"}),", ",(0,t.jsx)(s.em,{children:(0,t.jsx)(s.a,{href:"https://www.youtube.com/watch?v=pDd5mXBF4tY",children:"Intro to Embassy : embedded development with async Rust"})})]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"extra-resources",children:"Extra Resources"}),"\n",(0,t.jsxs)(s.ol,{start:"4",children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Raspberry Pi Ltd"}),", ",(0,t.jsx)(s.em,{children:(0,t.jsx)(s.a,{href:"https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf",children:"RP2350 Datasheet"})})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Raspberry Pi Ltd"}),", ",(0,t.jsx)(s.em,{children:(0,t.jsx)(s.a,{href:"https://datasheets.raspberrypi.com/pico/pico-2-datasheet.pdf",children:"Raspberry Pi Pico 2 Datasheet"})})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Raspberry Pi Ltd"}),", ",(0,t.jsx)(s.em,{children:(0,t.jsx)(s.a,{href:"https://datasheets.raspberrypi.com/picow/pico-2-w-datasheet.pdf",children:"Raspberry Pi Pico 2W Datasheet"})})]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"what-is-gpio",children:"What is GPIO?"}),"\n",(0,t.jsx)(s.p,{children:"General-Purpose Input/Output, or GPIO, is an essential part of embedded systems that serves as a vital conduit between microcontrollers and microprocessors and the outside world. A microcontroller or microprocessor's group of pins that can each be set to operate as an input or an output is referred to as GPIO. The purpose of these pins is to interface external components, including actuators, displays, sensors, and other devices, so that the embedded system may communicate with its surroundings. Standardised communication protocols like SPI, I2C, PCM, PWM, and serial communication may be directly supported by some GPIO pins. There are two varieties of GPIO pins: digital and analog."}),"\n",(0,t.jsx)(s.h2,{id:"configuring-gpio-pins",children:"Configuring GPIO Pins"}),"\n",(0,t.jsx)(s.p,{children:"GPIO pins can be used as outputs (LEDs, motors, buzzers) or as inputs (buttons, sensors)."}),"\n",(0,t.jsx)(s.p,{children:"The RP2040 and RP2350 have three peripherals that control the GPIO pins:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:"Pads"})," - control the actual physical pin or pad that the processor has outside. They control the electrical parameters, like maximum current or pull up and pull down resistors"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:"IO Bank0"})," - connects and multiplexes the peripheral's pins to the output pads. Several peripherals use the same output pad to communicate with the exterior. For example, in the image below, ",(0,t.jsx)(s.code,{children:"GPIO0"})," can be used either for:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SIO"})," - the ",(0,t.jsx)(s.code,{children:"GPIO"})," function"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SPI_RX"})," - the receive pin for the ",(0,t.jsx)(s.code,{children:"SPI"})," peripheral"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"I2C0_SDA"})," - the data pin for the ",(0,t.jsx)(s.code,{children:"I2C0"})," peripheral"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"UART0_TX"})," - the transmit pin for the ",(0,t.jsx)(s.code,{children:"UART0"})," (serial port 0) peripheral"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.em,{children:"SIO"})," - that controls the interior MCU's pins. This is the peripheral that developers use to read and write the value of the pins."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Pico2W Pinout",src:n(69185).A+"",width:"842",height:"595"})}),"\n",(0,t.jsxs)(s.p,{children:["Every pin of the MCU can perform multiple functions. Several peripherals need to use input and output pins.\nIt is the role of the ",(0,t.jsx)(s.em,{children:"IO Bank0"})," to multiplex and connect the peripherals to the pins."]}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"IO Bank0",src:n(57690).A+"",width:"1574",height:"1114"})})}),"\n",(0,t.jsx)(s.h2,{id:"hardware-access",children:"Hardware access"}),"\n",(0,t.jsx)(s.p,{children:"There are 3 different ways in which the hardware the Raspberry Pi Pico can be used:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Embassy framework, with the Embedded HAL implementation"}),"\n",(0,t.jsx)(s.li,{children:"Platform Access Crate (PAC)"}),"\n",(0,t.jsx)(s.li,{children:"Bare metal"}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"embassy-framework",children:"Embassy Framework"}),"\n",(0,t.jsx)(s.p,{children:"Developing bare metal firmware requires a lot of time."}),"\n",(0,t.jsxs)(s.p,{children:["In trying to standardize firmware development, The Rust ",(0,t.jsx)(s.a,{href:"https://www.rust-lang.org/governance/wgs/embedded",children:"Embedded devices Working Group"})," has designed\na set of standard traits (interfaces) for interacting with an MCU. This is called the ",(0,t.jsx)(s.strong,{children:"Embedded Hardware Abstraction Layer"}),", or shortly Embedded HAL. The main purpose is to define a common hardware interface that\nframeworks, libraries and operating systems can build upon. Regardless of what MCUs the device is using, the upper level software should be as portable as possible."]}),"\n",(0,t.jsxs)(s.p,{children:["There are several crates that implement the Embedded HAL traits for the RP2040 and RP2350 MCUs. These\ncrates are called ",(0,t.jsx)(s.em,{children:"HAL Implementations"}),"."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://docs.rs/rp235x-hal/latest/rp235x_hal/",children:"rp2350_hal"})," crate, implements just the embedded HAL traits, it is ",(0,t.jsx)(s.em,{children:"the bare minimum"})," for developing RP2350 applications"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://docs.rs/rp2040-hal/latest/rp2040_hal/",children:"rp2040_hal"})," crate, implements just the embedded HAL traits, it is ",(0,t.jsx)(s.em,{children:"the bare minimum"})," for developing RP2040 applications"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html",children:"embassy-rp"})," crate implements the Embedded HAL for RP2040 and RP2350 that is used with the ",(0,t.jsx)(s.a,{href:"https://embassy.dev/",children:"embassy-rs"})," framework"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Several frameworks are available on top of the ",(0,t.jsx)(s.em,{children:"HAL Implementations"})," to speed things up. The most common used ones are:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://rtic.rs",children:"RTIC - The hardware accelerated Rust RTOS"})," - ",(0,t.jsx)(s.em,{children:"A concurrency framework for building real-time systems"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"https://embassy.dev",children:"Embassy"})," - ",(0,t.jsx)(s.em,{children:"The next-generation framework for embedded applications"})]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"the-software-stack",children:"The Software Stack"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.a,{href:"https://embassy.dev/",children:"Embassy"})," is a full fledged embedded framework for Rust embedded development.\nBesides the implementation of the embedded HAL for different MCUs (RP2040 and RP2350 included), Embassy provides\nseveral functions like timers, BLE and network communication."]}),"\n",(0,t.jsx)("div",{align:"center",children:(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Rust EMbedded Stack",src:n(8743).A+"",width:"451",height:"291"})})}),"\n",(0,t.jsx)(s.p,{children:"The crates used by Embassy and their mapping are shown in the table bellow."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Crate"}),(0,t.jsx)(s.th,{children:"Position"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-executor/git/cortex-m/index.html",children:(0,t.jsx)(s.code,{children:"embassy-executor"})})}),(0,t.jsx)(s.td,{children:"Framework"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.a,{href:"https://docs.rs/smoltcp/latest/smoltcp/",children:(0,t.jsx)(s.code,{children:"smoltcp"})}),", ",(0,t.jsx)(s.a,{href:"https://docs.rs/defmt/latest/defmt/",children:(0,t.jsx)(s.code,{children:"defmt"})})]}),(0,t.jsx)(s.td,{children:"Libraries"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-net/git/default/index.html",children:(0,t.jsx)(s.code,{children:"embassy-net"})}),", ",(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-time/git/default/index.html",children:(0,t.jsx)(s.code,{children:"embassy-time"})}),", ",(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-usb/git/default/index.html",children:(0,t.jsx)(s.code,{children:"embassy-usb"})}),", ",(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-usb-logger/git/default/index.html",children:(0,t.jsx)(s.code,{children:"embassy-usb-logger"})})]}),(0,t.jsx)(s.td,{children:"Framework Driver"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-usb-driver/git/default/index.html",children:(0,t.jsx)(s.code,{children:"embassy-usb-driver"})}),", ",(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-time-driver/git/default/index.html",children:(0,t.jsx)(s.code,{children:"embassy-time-driver"})})]}),(0,t.jsx)(s.td,{children:"Embassy HAL (API)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/cyw43/git/default/index.html",children:(0,t.jsx)(s.code,{children:"cyw43"})}),", ",(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/cyw43-pio/git/default/index.html",children:(0,t.jsx)(s.code,{children:"cyw43-pio"})})]}),(0,t.jsx)(s.td,{children:"Driver (WiFi)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.a,{href:"https://docs.rs/embedded-hal/latest/embedded_hal/",children:(0,t.jsx)(s.code,{children:"embedded-hal"})}),", ",(0,t.jsx)(s.a,{href:"https://docs.rs/embedded-hal-async/latest/embedded_hal_async/",children:(0,t.jsx)(s.code,{children:"embedded-hal-async"})})]}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Rust Embedded HAL (Standard)"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/index.html",children:(0,t.jsx)(s.code,{children:"embassy_rp"})})}),(0,t.jsx)(s.td,{children:"HAL Implementation"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsxs)(s.td,{children:[(0,t.jsx)(s.a,{href:"https://docs.rs/cortex-m/latest/cortex_m/",children:(0,t.jsx)(s.code,{children:"cortex-m"})}),", ",(0,t.jsx)(s.a,{href:"https://docs.rs/cortex-m-rt/latest/cortex_m_rt/",children:(0,t.jsx)(s.code,{children:"cortex-m-rt"})})]}),(0,t.jsx)(s.td,{children:"\u03bc-architecture crates"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/rp-pac/git/default/index.html",children:(0,t.jsx)(s.code,{children:"rp_pac"})})}),(0,t.jsx)(s.td,{children:"Platform Access Crate"})]})]})]}),"\n",(0,t.jsx)(s.admonition,{type:"info",children:(0,t.jsxs)(s.p,{children:["The name ",(0,t.jsx)(s.em,{children:"Embassy"})," is derived from ",(0,t.jsx)(s.strong,{children:"Emb"}),"edded ",(0,t.jsx)(s.strong,{children:"Asy"}),"nchronous Rust."]})}),"\n",(0,t.jsxs)(s.h3,{id:"empty-embassy-firmware",children:[(0,t.jsx)(s.em,{children:"Empty"})," Embassy Firmware"]}),"\n",(0,t.jsxs)(s.p,{children:["The Embassy Framework is a collection of crates. Building an ",(0,t.jsx)(s.em,{children:"empty"})," firmware that uses\nembassy requires:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"adding the Embassy HAL Implementation for a specific board, in this case RP2350;"}),"\n",(0,t.jsx)(s.li,{children:"adding the core Embassy crates, that provide the executor, timers and futures;"}),"\n",(0,t.jsxs)(s.li,{children:["adding the ",(0,t.jsx)(s.code,{children:"cortex-m-rt"})," and ",(0,t.jsx)(s.code,{children:"defmt"})," crates that Embassy requires."]}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-toml",children:'# RP2350 HAL\nembassy-rp = { version = "0.3.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "unstable-pac", "time-driver", "critical-section-impl", "rp235xa", "binary-info"] }\n\n# Embedded HAL utilities\nembassy-embedded-hal = { version = "0.3.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Synchronization primitives and data structures with async support\nembassy-sync = { version = "0.6.2", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Async/await executor\nembassy-executor = { version = "0.7.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["task-arena-size-98304", "arch-cortex-m", "executor-thread", "executor-interrupt", "defmt"] }\n\n# Utilities for working with futures, compatible with no_std and not using alloc\nembassy-futures = { version = "0.1.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6" }\n\n# Timekeeping, delays and timeouts\nembassy-time = { version = "0.4.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "defmt-timestamp-uptime"] }\n\n# USB device\nembassy-usb = { version = "0.4.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Network stack\nembassy-net = { version = "0.7.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "tcp", "udp", "raw", "dhcpv4", "medium-ethernet", "dns"] }\nembassy-net-wiznet = { version = "0.2.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# USB logging\nembassy-usb-logger = { version = "0.4.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6" }\nlog = "0.4"\n\n# WiFi Chip\ncyw43 = { version = "0.3.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt", "firmware-logs"] }\ncyw43-pio = { version = "0.3.0", git = "https://github.com/embassy-rs/embassy", rev = "2e7a2b6", features = ["defmt"] }\n\n# Defmt support\ndefmt = "0.3"\ndefmt-rtt = "0.4"\n\n# Low level access to Cortex-M processors\n# cortex-m = { version = "0.7.6", features = ["inline-asm"] }\ncortex-m-rt = "0.7.0"\n\n# Panic handler that exits `probe-run` with an error code\npanic-probe = { version = "0.3", features = ["print-defmt"] }\n'})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-rp"})," crate provides support for the Raspberry Pi RP2350\nmicrocontroller within the Embassy framework. It includes features such\nas ",(0,t.jsx)(s.code,{children:"defmt"})," for efficient debugging, ",(0,t.jsx)(s.code,{children:"unstable-pac"})," for accessing low-level\nperipherals, and ",(0,t.jsx)(s.code,{children:"time-driver"})," for handling time-related operations.\nThe crate also implements ",(0,t.jsx)(s.code,{children:"critical-section"})," for safe concurrency and\nsupports ",(0,t.jsx)(s.code,{children:"rp235xa"})," and ",(0,t.jsx)(s.code,{children:"binary-info"})," for additional RP2350-specific\nfunctionality."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-embedded-hal"})," crate provides embedded-hal-compatible utilities\nfor asynchronous embedded development. It enables easy interaction with\nhardware peripherals, such as GPIO, SPI, and I2C, while integrating with\nthe Embassy async runtime. It includes ",(0,t.jsx)(s.code,{children:"defmt"})," for lightweight debugging."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-sync"})," crate offers synchronization primitives and data\nstructures designed for async environments. It includes mutexes, signal\nprimitives, and channel-based communication for safe, cooperative\nmultitasking. The crate is optimized for ",(0,t.jsx)(s.code,{children:"no_std"})," systems and supports\n",(0,t.jsx)(s.code,{children:"defmt"})," for debugging."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-executor"})," crate provides an async/await executor tailored for\nembedded systems. It supports multitasking via interrupt-based and\nthread-based execution models, with optimizations for Cortex-M\nmicrocontrollers. Features include configurable task arena sizes and\n",(0,t.jsx)(s.code,{children:"defmt"})," for debugging."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-futures"})," crate supplies utilities for working with Rust futures\nin embedded environments. It is designed to be compatible with ",(0,t.jsx)(s.code,{children:"no_std"}),"\nand avoids dynamic memory allocation, making it lightweight and efficient\nfor constrained devices."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-time"})," crate handles timekeeping, delays, and timeouts in async\napplications. It provides a high-precision time driver and supports uptime-based\ntimestamps for logging. The crate is optimized for ",(0,t.jsx)(s.code,{children:"no_std"}),"\nenvironments and integrates with ",(0,t.jsx)(s.code,{children:"defmt"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-usb"})," crate provides a USB device stack for embedded systems. It\nsupports USB control, bulk, and interrupt transfers, making it useful for\nimplementing HID, CDC, and other USB classes. It integrates with ",(0,t.jsx)(s.code,{children:"defmt"}),"\nfor debugging and logging."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-net"})," crate implements a network stack with support for TCP,\nUDP, and raw Ethernet frames. It includes DHCPv4 for automatic IP\nconfiguration and DNS resolution. The crate is designed for embedded\nnetworking and integrates with ",(0,t.jsx)(s.code,{children:"defmt"})," for efficient debugging."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-net-wiznet"})," crate adds support for WIZnet Ethernet modules to\nthe Embassy networking stack. It provides an async interface for handling\nnetwork communication over SPI-connected WIZnet chips, with ",(0,t.jsx)(s.code,{children:"defmt"}),"\nintegration for logging."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy-usb-logger"})," crate enables USB-based logging for embedded\napplications. It provides a mechanism for transmitting log messages over\nUSB, allowing for real-time debugging and monitoring of embedded systems."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"log"})," crate is a lightweight logging facade that allows messages to be\nrecorded using different logging backends. It is widely used in Rust\nprojects, including embedded systems, to enable flexible debugging and\nmonitoring."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"cyw43"})," crate provides support for the CYW43 Wi-Fi chip, commonly found\non Raspberry Pi Pico W. It includes firmware logging, ",(0,t.jsx)(s.code,{children:"defmt"})," integration,\nand an async interface for managing Wi-Fi connections in embedded systems."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"cyw43-pio"})," crate offers PIO (Programmable I/O) support for the CYW43\nWi-Fi chip, enabling efficient SPI communication between the microcontroller\nand the Wi-Fi module. It includes ",(0,t.jsx)(s.code,{children:"defmt"})," logging for debugging low-level\ninteractions."]}),"\n",(0,t.jsx)(s.h3,{id:"entry",children:"Entry"}),"\n",(0,t.jsxs)(s.p,{children:["Embassy is a framework built on top of ",(0,t.jsx)(s.code,{children:"cortex-m-rt"})," and provides its own method of defining\nthe entrypoint and bootloader."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"#![no_main]\n#![no_std]\n\nuse embassy_executor::Spawner;\n\n#[embassy_executor::main]\nasync fn main(_spawner: Spawner) {\n    let peripherals = embassy_rp::init(Default::default());\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"embassy_rp::init"})," function takes care of the peripheral initialization so that developers can jump\nright in and use them."]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["Embassy is designed to work in an asynchronous way and this is why the ",(0,t.jsx)(s.code,{children:"main"})," function is defined as ",(0,t.jsx)(s.code,{children:"async"}),". For the time being, just take it as a must and ignore it."]})}),"\n",(0,t.jsx)(s.h3,{id:"configure-gpio-output",children:"Configure GPIO Output"}),"\n",(0,t.jsxs)(s.p,{children:["Embassy provides one single function that returns the GPIO ",(0,t.jsx)(s.code,{children:"Output"})," pin and hides the configuration\ndetails from developers."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"pin"})," variable implements the embadded HAL ",(0,t.jsx)(s.a,{href:"https://docs.rs/embedded-hal/latest/embedded_hal/digital/trait.OutputPin.html",children:(0,t.jsx)(s.code,{children:"OutputPin"})})," trait."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"use gpio::{Level, Output};\n\n// initialize PIN_n (replace n with a number) and set its\n// default value to LOW (0)\nlet mut pin = Output::new(peripherals.PIN_n, Level::Low);\n\n// set the pin value to HIGH (1)\npin.set_high();\n\n// set the pin value to LOW (0)\npin.set_low();\n"})}),"\n",(0,t.jsx)(s.admonition,{type:"tip",children:(0,t.jsxs)(s.p,{children:["While the device initialization is specific to every hardware device (the example uses the\n",(0,t.jsx)(s.code,{children:"embassy_rp"})," crate that is for RP2350 and RP2040), the pin initialization and usage is portable. It\nuses the same code, regardless of the MCU used."]})}),"\n",(0,t.jsx)(s.h3,{id:"configure-gpio-input",children:"Configure GPIO Input"}),"\n",(0,t.jsx)(s.p,{children:"Using a pin as input is very similar to using it as output."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"use gpio::{Input, Pull};\n\nlet pin = Input::new(peripherals.PIN_n, Pull::Up);\n\nif pin.is_high() {\n    // Do something if the pin value is HIGH (1)\n} else {\n    // Do something if the pin value if LOW (0)\n}\n"})}),"\n",(0,t.jsxs)(s.admonition,{type:"warning",children:[(0,t.jsx)(s.mdxAdmonitionTitle,{}),(0,t.jsxs)(s.p,{children:["For a correct use of the buttons, use pull-up, pull-down resistors depending on the mode of operation of the button. Check ",(0,t.jsx)(l,{title:"Buttons",anchor:"buttons"})," section from the ",(0,t.jsx)(l,{}),"."]})]}),"\n",(0,t.jsx)(s.h3,{id:"waiting-for-gpio-input",children:"Waiting for GPIO Input"}),"\n",(0,t.jsx)(s.p,{children:"Embassy provides a set of functions that are able to suspend the execution of the task\nuntil a change is detected in the input if a GPIO pin."}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Function"}),(0,t.jsx)(s.th,{children:"Description"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_high",children:(0,t.jsx)(s.code,{children:"wait_for_high"})})}),(0,t.jsxs)(s.td,{children:["Suspends the execution until the pin state becomes ",(0,t.jsx)(s.code,{children:"Level::High"}),". If the pin state is already ",(0,t.jsx)(s.code,{children:"Level::High"}),", it returns immediately."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_low",children:(0,t.jsx)(s.code,{children:"wait_for_low"})})}),(0,t.jsxs)(s.td,{children:["Suspends the execution until the pin state becomes ",(0,t.jsx)(s.code,{children:"Level::Low"}),". If the pin state is already ",(0,t.jsx)(s.code,{children:"Level::Low"}),", it returns immediately."]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_any_edge",children:(0,t.jsx)(s.code,{children:"wait_for_any_edge"})})}),(0,t.jsx)(s.td,{children:"Suspends the execution until the pin state switches."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_rising_edge",children:(0,t.jsx)(s.code,{children:"wait_for_rising_edge"})})}),(0,t.jsxs)(s.td,{children:["Suspends the execution until the pin state switches from ",(0,t.jsx)(s.code,{children:"Level::Low"})," to ",(0,t.jsx)(s.code,{children:"Level::High"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.Input.html#method.wait_for_falling_edge",children:(0,t.jsx)(s.code,{children:"wait_for_falling_edge"})})}),(0,t.jsxs)(s.td,{children:["Suspends the execution until the pin state switches ",(0,t.jsx)(s.code,{children:"Level::High"})," to ",(0,t.jsx)(s.code,{children:"Level::Low"})]})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"waiting",children:"Waiting"}),"\n",(0,t.jsxs)(s.p,{children:["Embassy provides support for suspending the execution of the software for an amount of time. It uses\nthe ",(0,t.jsx)(s.a,{href:"https://docs.rs/embassy-time/0.3.0/embassy_time/struct.Timer.html",children:(0,t.jsx)(s.code,{children:"Timer"})})," structure from the\n",(0,t.jsx)(s.a,{href:"https://docs.rs/embassy-time/latest/embassy_time/",children:(0,t.jsx)(s.code,{children:"embassy_time"})})," crate."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:"// suspend the execution for a period of time\nuse embassy_time::Timer;\n\nTimer::after_secs(1).await;\n"})}),"\n",(0,t.jsx)(s.admonition,{type:"tip",children:(0,t.jsx)(s.p,{children:"If the MCU provides timers, the Embassy framework will use them to suspend the software. This is very efficient."})}),"\n",(0,t.jsx)(s.h2,{id:"the-lab-board",children:"The lab board"}),"\n",(0,t.jsx)(s.p,{children:"This lab makes use of the hardware available on the lab board. The board provides:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Raspberry Pi Pico/2 Slot"}),"\n",(0,t.jsx)(s.li,{children:"RP2040 Debugger"}),"\n",(0,t.jsx)(s.li,{children:"4 buttons"}),"\n",(0,t.jsx)(s.li,{children:"5 LEDs"}),"\n",(0,t.jsx)(s.li,{children:"potentiometer"}),"\n",(0,t.jsx)(s.li,{children:"buzzer"}),"\n",(0,t.jsx)(s.li,{children:"photoresistor"}),"\n",(0,t.jsx)(s.li,{children:"I2C EEPROM"}),"\n",(0,t.jsx)(s.li,{children:"BMP280 Pressure & Temp. sensor"}),"\n",(0,t.jsx)(s.li,{children:"SPI LCD Display"}),"\n",(0,t.jsx)(s.li,{children:"SD Card Reader"}),"\n",(0,t.jsx)(s.li,{children:"USB-C connector"}),"\n",(0,t.jsx)(s.li,{children:"servo connectors"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Lab Board",src:n(28230).A+"",width:"1024",height:"980"})}),"\n",(0,t.jsx)(s.admonition,{type:"danger",children:(0,t.jsxs)(s.p,{children:["Please make sure you use the ",(0,t.jsx)(s.strong,{children:"USB-C connector"})," to connect the board to the computer."]})}),"\n",(0,t.jsx)(s.h3,{id:"wiring",children:"Wiring"}),"\n",(0,t.jsx)(s.p,{children:"All the electronic components, sensors and actuators, have the power pins hard wired\nto the board. This means that all the components receive power from the board\nand do not have to be powered separately."}),"\n",(0,t.jsxs)(s.p,{children:["The data pins of the components are not wired and have to be connected to the\nRaspberry Pi Pico using ",(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Jump_wire",children:"jumper wires"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"raspberry-pi-pico-pins",children:"Raspberry Pi Pico Pins"}),"\n",(0,t.jsxs)(s.p,{children:["Each pin on the Raspberry PI Pico 2 is connected to ",(0,t.jsx)(s.strong,{children:"two-hole connectors"})," positioned\nalong the sides of the socket, marked with labels like ",(0,t.jsx)(s.strong,{children:"GP0, GP1, GP2"}),", etc.\nThese holes provide an easy way to access the ",(0,t.jsx)(s.strong,{children:"GPIO (General-Purpose Input/Output)\npins"})," of the Pico 2."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Lab Board Connectors",src:n(20494).A+"",width:"562",height:"382"})}),"\n",(0,t.jsx)(s.p,{children:"You have to use jumper wires to interface with the Pico 2\u2019s GPIO pins as follows:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Insert a ",(0,t.jsx)(s.strong,{children:"male jumper wire"})," into one of the pin holes corresponding to the desired GPIO pin."]}),"\n",(0,t.jsxs)(s.li,{children:["Connect ",(0,t.jsx)(s.strong,{children:"the other end"})," of the jumper wire to an external circuit, such as a breadboard,\nanother microcontroller, or a peripheral device. In this case, it will be LEDs or Switches."]}),"\n",(0,t.jsxs)(s.li,{children:["Use the ",(0,t.jsx)(s.strong,{children:"second hole"})," of the same pin as an additional connection point,\nallowing multiple devices to share the same GPIO."]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{type:"warning",children:(0,t.jsxs)(s.p,{children:["Pins ",(0,t.jsx)(s.code,{children:"GP0"})," and ",(0,t.jsx)(s.code,{children:"GP1"})," should only be used for UART (Serial) communication\nas they are connected to the lab board's debugger chip."]})}),"\n",(0,t.jsx)(s.h3,{id:"leds-and-switches",children:"LEDs and Switches"}),"\n",(0,t.jsxs)(s.p,{children:["The board provides four single colored LEDs, red, green, blue and yellow. Each one of them\nuses one pin for control. Each LED connector has one single hole on the board,\nmarked with ",(0,t.jsx)(s.code,{children:"RED"}),", ",(0,t.jsx)(s.code,{children:"GREEN"}),", ",(0,t.jsx)(s.code,{children:"BLUE"})," and ",(0,t.jsx)(s.code,{children:"YELLOW"})," respectively. These are located in the ",(0,t.jsx)(s.strong,{children:"Connectors"}),"\nsection of the board."]}),"\n",(0,t.jsx)(s.admonition,{type:"warning",children:(0,t.jsxs)(s.p,{children:["The LEDs are connected so they will light up if the pin is set to ",(0,t.jsx)(s.code,{children:"Level::Low"})," and turn off if the pin is set to ",(0,t.jsx)(s.code,{children:"Level::High"}),"."]})}),"\n",(0,t.jsxs)(s.p,{children:["The four switches that the lab board provides are signaled with labels\n",(0,t.jsx)(s.code,{children:"SW4"}),", ",(0,t.jsx)(s.code,{children:"SW5"}),", ",(0,t.jsx)(s.code,{children:"SW6"})," and ",(0,t.jsx)(s.code,{children:"SW7"})," in the connectors section."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Lab Board Connectors",src:n(95963).A+"",width:"991",height:"436"})}),"\n",(0,t.jsxs)(s.admonition,{type:"warning",children:[(0,t.jsx)(s.p,{children:"Switches on the lab board have a pull-up resistor. This means that:"}),(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"The values it provides may be counter-intuitive:"}),"\n"]}),(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Position"}),(0,t.jsx)(s.th,{children:"Value"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Pressed"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Level::Low"})})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Released"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"Level::High"})})]})]})]}),(0,t.jsxs)(s.ol,{start:"2",children:["\n",(0,t.jsxs)(s.li,{children:["Pins that connect to switches have to be set up as ",(0,t.jsx)(s.code,{children:"Pull::None"})," to disable the Raspberry Pi 2 Pico's\ninternal pull resistor."]}),"\n"]})]}),"\n",(0,t.jsx)(s.h3,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(s.p,{children:["To wire the green LED to pin 7 of the Raspberry Pi Pico 2, a jumper cable is required\nbetween holes ",(0,t.jsx)(s.code,{children:"GREEN"})," and ",(0,t.jsx)(s.code,{children:"GP7"}),"."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Lab Board Connectors",src:n(57546).A+"",width:"997",height:"435"})}),"\n",(0,t.jsx)(s.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Write an ",(0,t.jsx)(s.em,{children:"empty"})," firmware that uses the Embassy Framework and ",(0,t.jsx)(s.code,{children:"defmt"}),". (",(0,t.jsx)(s.strong,{children:"1p"}),")\nMake sure you follow these steps:"]}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["create a new Rust project using ",(0,t.jsx)(s.code,{children:"cargo init"}),";"]}),"\n",(0,t.jsxs)(s.li,{children:["add the ",(0,t.jsx)(s.code,{children:".cargo/config.toml"})," file that instructs ",(0,t.jsx)(s.code,{children:"cargo"})," to ",(0,t.jsx)(s.a,{href:"./01#using-a-configuration-file",children:"cross-compile"})," for the ",(0,t.jsx)(s.code,{children:"thumbv8m.main-none-eabihf"}),"\narchitecture, add ",(0,t.jsx)(s.code,{children:"probe-rs run"})," as a ",(0,t.jsx)(s.a,{href:"./01#using-cargo-run",children:"runner"})," and set ",(0,t.jsxs)(s.a,{href:"./01#filtering-messages",children:[(0,t.jsx)(s.code,{children:"defmt"})," messages filtering"]})," to ",(0,t.jsx)(s.code,{children:"DEBUG"}),";"]}),"\n",(0,t.jsxs)(s.li,{children:["add the ",(0,t.jsx)(s.a,{href:"./01#linker-script",children:"linker script"})," file called ",(0,t.jsx)(s.code,{children:"memory.x"}),";"]}),"\n",(0,t.jsxs)(s.li,{children:["add the ",(0,t.jsx)(s.a,{href:"./01#build-script",children:"build script"})," file called ",(0,t.jsx)(s.code,{children:"build.rs"}),";"]}),"\n",(0,t.jsxs)(s.li,{children:["add the required ",(0,t.jsx)(s.em,{children:"Embassy"})," dependencies - take a look at ",(0,t.jsxs)(s.a,{href:"#empty-embassy-firmware",children:[(0,t.jsx)(s.em,{children:"Empty"})," Embassy Firmware"]})," - take a look at ",(0,t.jsxs)(s.a,{href:"./01#empty-firmware",children:[(0,t.jsx)(s.em,{children:"Empty"})," Firmware"]}),";"]}),"\n",(0,t.jsxs)(s.li,{children:["use ",(0,t.jsx)(s.code,{children:"defmt_rtt"})," as a logger, make sure you import it even if you are not using it directly ",(0,t.jsx)(s.code,{children:"use ... as _"}),";"]}),"\n",(0,t.jsxs)(s.li,{children:["use ",(0,t.jsx)(s.code,{children:"panic-probe"})," to provide a panic handler, make sure you import it even if you are not using it directly ",(0,t.jsx)(s.code,{children:"use ... as _"}),";"]}),"\n",(0,t.jsxs)(s.li,{children:["ask the Rust compiler not to depend on the standard library,\nnot to provide a main function and\nadd the ",(0,t.jsx)(s.em,{children:"Embassy"})," ",(0,t.jsx)(s.a,{href:"#entry",children:"entry"}),";"]}),"\n",(0,t.jsxs)(s.li,{children:["write the code to print the ",(0,t.jsx)(s.code,{children:"info!"}),' message "Device started".']}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Please make sure you comment out (using ",(0,t.jsx)(s.code,{children:"#"})," in from of the line) all the Embassy's crates\nthat you do not plan to use."]}),"\n",(0,t.jsxs)(s.admonition,{type:"warning",children:[(0,t.jsxs)(s.p,{children:["Please make sure the ",(0,t.jsx)(s.code,{children:"embassy_rp"})," crate is included in your build either:"]}),(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["by importing it with ",(0,t.jsx)(s.code,{children:"use embassy_rp as _;"})]}),"\n",(0,t.jsx)(s.li,{children:"or by initialising the peripherals"}),"\n"]}),(0,t.jsxs)(s.p,{children:["This crate provides the ",(0,t.jsx)(s.code,{children:".start_block"})," section that is needed by the RP2350 to boot. Not including\nthis crate will prevent this section from being added and will prevent the RP2350 to boot."]})]}),"\n",(0,t.jsx)(s.admonition,{type:"info",children:(0,t.jsx)(s.p,{children:"For sure, you will  not use USB and WiFi. This is a trial\nand error job, just comment out all the creates that you think you won't use and\nadd them back if the compiler asks for them."})}),"\n",(0,t.jsxs)(s.p,{children:["To prevent ",(0,t.jsx)(s.code,{children:"rust-analyzer"})," from showing an error on the first line and to automatically\nformat your source when saving, create a ",(0,t.jsx)(s.code,{children:".vscode/settings.json"})," file with:"]}),"\n",(0,t.jsx)(s.admonition,{type:"tip",children:(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'{\n    "rust-analyzer.cargo.allTargets": false,\n    "[rust]": {\n        "editor.defaultFormatter": "rust-lang.rust-analyzer",\n        "editor.formatOnSave": true,\n        "editor.formatOnSaveMode": "file",\n    },\n}\n'})})}),"\n",(0,t.jsxs)(s.ol,{start:"2",children:["\n",(0,t.jsxs)(s.li,{children:["Write a program using Embassy that set on HIGH the LED connected to GPIO pin 2 (GP2). (",(0,t.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(s.admonition,{type:"danger",children:[(0,t.jsx)(s.mdxAdmonitionTitle,{}),(0,t.jsx)(s.p,{children:"Please make sure the lab professor verifies your circuit before it is powered up."})]}),"\n",(0,t.jsxs)(s.ol,{start:"3",children:["\n",(0,t.jsxs)(s.li,{children:["Write a program using Embassy that blinks the LED connected to GPIO pin 2 (GP2)\nevery 300ms. (",(0,t.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["For the purpose of this lab, please use ",(0,t.jsx)(s.code,{children:"await"})," as is, think that for\nusing the ",(0,t.jsx)(s.code,{children:"Timer"}),", you have to add ",(0,t.jsx)(s.code,{children:".await"})," after the ",(0,t.jsx)(s.code,{children:"after"})," function."]})}),"\n",(0,t.jsxs)(s.ol,{start:"4",children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:['Write a program using Embassy that will write the\nmessage "The button was pressed" to the console every time button SW5 is pressed.\nMake sure you connect the switch SW5 to a Raspberry Pi Pico 2 pin. (',(0,t.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Write a Rust program using Embassy that toggles the LED every time button SW5 is pressed.\nThe message might be printed many times for one press? Why? (",(0,t.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{type:"tip",children:(0,t.jsxs)(s.p,{children:["Read the value of SW5 in a ",(0,t.jsx)(s.code,{children:"loop"})," and print the message if the value is ",(0,t.jsx)(s.code,{children:"LOW"}),"."]})}),"\n",(0,t.jsxs)(s.ol,{start:"6",children:["\n",(0,t.jsxs)(s.li,{children:["Instead of constantly sampling for the button value, use the ",(0,t.jsx)(s.a,{href:"#waiting-for-gpio-input",children:"wait pin functions"})," to\nwait for the value to change. Why is the message printed only once? (",(0,t.jsx)(s.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{type:"tip",children:(0,t.jsxs)(s.p,{children:["Do not forget to write the ",(0,t.jsx)(s.code,{children:".await"})," keyword at the end of an ",(0,t.jsx)(s.code,{children:"async"})," function call."]})}),"\n",(0,t.jsxs)(s.ol,{start:"7",children:["\n",(0,t.jsxs)(s.li,{children:["Build a traffic light using the ",(0,t.jsx)(s.code,{children:"GREEN"}),", ",(0,t.jsx)(s.code,{children:"YELLOW"})," and ",(0,t.jsx)(s.code,{children:"RED"})," LEDs. (",(0,t.jsx)(s.strong,{children:"1p"}),") The flow of the colors\nis:"]}),"\n"]}),"\n",(0,t.jsx)(s.mermaid,{value:"flowchart LR\n    red(RED) -- 3s --\x3e green(Green)\n    green -- 3s --\x3e yellow(Yellow)\n    yellow -- 1s --\x3e red\n\n    classDef red fill:#ff0000,stroke:#000000,color: #ffffff\n    classDef yellow fill:#efa200,stroke:#000000\n    classDef green fill:#00ce54,stroke:#000000\n\n    class red red\n    class yellow yellow\n    class green green"}),"\n",(0,t.jsxs)(s.ol,{start:"8",children:["\n",(0,t.jsxs)(s.li,{children:["Extend the traffic light to include a flashing blue LED for pedestrians.\nWhen the pedestrian button is pressed, the traffic light switches to yellow\nand waits one second. After that, it switches on the red light and flashes\nthe blue pedestrian light. After 5 seconds, the traffic light switches back\nto green and stops the blue flashing. (",(0,t.jsx)(s.strong,{children:"2p"}),")"]}),"\n"]}),"\n",(0,t.jsx)(s.mermaid,{value:"flowchart LR\n    green(GREEN) --\x3e switch(Wait for pedestrian \n    button press)\n    switch --\x3e yellow(Yellow)\n    yellow -- 1s --\x3e red(RED)\n    yellow -- 1s --\x3e blue(BLUE blinking)\n    blue -- 5s --\x3e green\n\n    classDef red fill:#ff0000,stroke:#000000,color: #ffffff\n    classDef yellow fill:#efa200,stroke:#000000\n    classDef green fill:#00ce54,stroke:#000000\n    classDef blue fill:#009fff,stroke:#000000,color: #ffffff\n\n    class red red\n    class yellow yellow\n    class green green\n    class blue blue"}),"\n",(0,t.jsxs)(s.ol,{start:"9",children:["\n",(0,t.jsxs)(s.li,{children:["Display letters in Morse Code.","\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Write a function that takes as an argument a letter and displays\nit in Morse Code using three LEDs. For a dot light up the middle LED,\nfor a line light up all three. (",(0,t.jsx)(s.strong,{children:"1p"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:["Write a firmware that displays a text in Morse Code. (",(0,t.jsx)(s.strong,{children:"1p"}),")\n",(0,t.jsx)(s.img,{alt:"International Morse Code",src:n(25638).A+"",width:"414",height:"530"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["Letters in Morse Code are case insensitive. You can use the ",(0,t.jsx)(s.a,{href:"https://doc.rust-lang.org/beta/core/primitive.char.html#method.to_ascii_uppercase",children:(0,t.jsx)(s.code,{children:"char::to_ascii_uppercase"})}),"\nor ",(0,t.jsx)(s.a,{href:"https://doc.rust-lang.org/std/primitive.u8.html#method.to_ascii_uppercase",children:(0,t.jsx)(s.code,{children:"u8::to_ascii_uppercase"})})," functions to convert a ",(0,t.jsx)(s.code,{children:"char"})," or ",(0,t.jsx)(s.code,{children:"u8"})," to uppercase."]})}),"\n",(0,t.jsxs)(s.admonition,{type:"tip",children:[(0,t.jsxs)(s.p,{children:["You can use an array of ",(0,t.jsx)(s.code,{children:"&str"}),"s to store the format of the morse code."]}),(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-rust",children:'const CODES: [&str; 26] = [\n    ".-", // A\n    // ...\n];\n'})})]})]})}function m(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},57690:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/gpio_mux-e4a348a45def684b56fdace777269f64.png"},25638:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/international_morse_code-4f915afa04938b9fedff8a08c8050a8f.svg"},28230:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/lab_board-3fa09dc706781d6e6c7126212ca9d240.png"},95963:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/lab_board_connectors-26ff5e8bbcba6c79ee2ec02d1172de56.png"},20494:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/lab_board_gp-778f6d10d7ab8eee649624ad53df1db2.png"},57546:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/lab_board_wired-4ca3acf64955108210b707fdee675375.png"},69185:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/pico2w-pinout-49532ea10ab0caedc6a6f21d1bf504bf.svg"},8743:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/rust_embedded_stack-8b3f636797a4c516d4202359f33d0143.svg"},28453:(e,s,n)=>{n.d(s,{R:()=>d,x:()=>a});var i=n(96540);const t={},r=i.createContext(t);function d(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);